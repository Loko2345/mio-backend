<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindTrack - Diario del Benessere</title>
    <script>
  const API_BASE = 'https://mio-backend-v00t.onrender.com';
</script>
    <!-- Librerie esterne caricate con attributi di ottimizzazione -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js" integrity="sha512-ElRFoEQdI5Ht6kZvyzXhYG9NqjtkmlkfYk0wr6wHxU9JEHakS7UJZNeml5ALk+8IKlU6jDgMabC3vkumRokgJA==" crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
    
    <style>
        /* ===================================
           CSS Variables & Theme Configuration
           =================================== */
        :root {
            /* Primary Colors */
            --primary-color: #2563eb;
            --primary-hover: #1d4ed8;
            --secondary-color: #4f46e5;
            --secondary-hover: #4338ca;
            --tertiary-color: #059669;
            --tertiary-hover: #047857;
            --danger-color: #dc2626;
            --danger-hover: #b91c1c;
            
            /* Text Colors */
            --text-color: #1f2937;
            --text-secondary: #4b5563;
            --text-muted: #6b7280;
            
            /* Background Colors */
            --bg-color: #f9fafb;
            --bg-alt: #ffffff;
            --border-color: #e5e7eb;
            --border-focus: var(--primary-color);
            
            /* Feedback Colors */
            --success-color: #166534;
            --success-bg: #dcfce7;
            --error-color: #b91c1c;
            --error-bg: #fee2e2;
            --info-bg: #eff6ff;
            --info-border: #93c5fd;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px 0 rgba(0,0,0,0.05);
            --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -4px rgba(0,0,0,0.1);
            
            /* Borders & Transitions */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
            --transition: all 0.2s ease-in-out;
        }

        /* ===================================
           Global Resets & Base Styles
           =================================== */
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        html { 
            scroll-behavior: smooth; 
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            min-height: 100vh;
            overflow-x: hidden;
            color: var(--text-color);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
        }

        /* ===================================
           Page Structure & Transitions
           =================================== */
        .page {
            width: 100%; 
            min-height: 100vh;
            display: none; /* Inizialmente tutte le pagine sono nascoste */
            flex-direction: column;
            background-color: var(--bg-alt); /* Default background */
        }
        
        /* Mostriamo solo la pagina di login all'inizio */
        #login-page { 
            display: flex; /* Questa pagina è visibile */
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #e6f2ff 0%, #d1e7ff 100%);
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        #intro-page { 
            justify-content: center;
        }
        
        #app-page {
            background-color: var(--bg-color);
            flex-grow: 1;
        }

        /* --- Intro Page Styles --- */
        .intro-content {
            display: flex; flex-direction: column; align-items: center;
            justify-content: center; text-align: center; padding: 2rem;
        }
        .intro-title {
            font-size: clamp(2rem, 6vw, 2.8rem); margin-bottom: 1.5rem;
            color: var(--primary-color); font-weight: 700;
        }
        .intro-subtitle {
            font-size: clamp(1rem, 4vw, 1.25rem); color: var(--text-secondary);
            margin-bottom: 3rem; max-width: 500px;
        }
        .start-btn {
            display: flex; align-items: center; justify-content: center;
            width: 65px; height: 65px; background-color: var(--secondary-color);
            color: white; border: none; border-radius: 50%; font-size: 1.8rem;
            cursor: pointer; transition: var(--transition); box-shadow: var(--shadow-lg);
        }
        .start-btn:hover {
            background-color: var(--secondary-hover); transform: scale(1.1);
            box-shadow: var(--shadow-md);
        }

        /* ===================================
           Header & Main App Structure
           =================================== */
        header {
            background-color: var(--primary-color); 
            color: white; 
            padding: 1.5rem 1rem;
            text-align: center; 
            box-shadow: var(--shadow-sm);
        }
        
        header h1 { 
            font-size: 2.2rem; 
            font-weight: 700; 
            letter-spacing: -0.5px; 
        }

        /* ===================================
           Navigation Bar
           =================================== */
        nav {
            background-color: var(--bg-alt); padding: 0.75rem 1rem;
            display: flex; justify-content: center; flex-wrap: wrap;
            gap: 0.75rem; box-shadow: var(--shadow-sm);
            border-bottom: 1px solid var(--border-color);
            position: relative;
        }
        nav button {
            background: none; border: none; padding: 0.6rem 1.1rem;
            border-radius: var(--radius-lg); cursor: pointer; display: flex;
            align-items: center; gap: 0.5rem; color: var(--text-secondary);
            transition: var(--transition); font-size: 0.95rem; font-weight: 500;
        }
        nav button:hover { background-color: #f3f4f6; color: var(--text-color); }
        nav button.active {
            background-color: #dbeafe; color: #1e40af; font-weight: 600;
        }
        nav button span { font-size: 1.1em; display: inline-block; margin-right: 2px; }

        /* --- Main App Container & Views --- */
        .app-container {
            padding: 1.5rem 1rem; display: flex; justify-content: center;
            flex-grow: 1;
        }
        
        .view-container {
            background-color: var(--bg-alt); padding: clamp(0.8rem, 4vw, 1.5rem);
            border-radius: var(--radius-lg); box-shadow: var(--shadow-md);
            max-width: 950px; width: 100%; display: none;
            border: 1px solid var(--border-color);
        }
        
        /* Specifiche dimensioni per la view dei grafici */
        #chart-view.view-container {
            max-width: 950px; /* Dimensione standard per grafici */
            margin: 0 auto;
        }

        /* --- Section Titles --- */
        h2 {
            font-size: 1.3rem; color: var(--primary-color); margin-bottom: 1.2rem;
            font-weight: 600; border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.75rem;
        }
        h3 { /* Consistent styling for sub-headings */
            font-size: 1.2rem; font-weight: 600; color: var(--text-color);
            margin-bottom: 0.75rem;
        }

        /* ===================================
           Form Elements & Inputs
           =================================== */
        .form-group { 
            margin-bottom: 1.4rem; 
        }
        
        label {
            display: block; 
            margin-bottom: 0.6rem; 
            color: var(--text-secondary);
            font-weight: 500; 
            font-size: 0.95rem;
        }
        label .emoji-label { margin-right: 0.4rem; font-size: 1.1em; }
        .slider-value {
            font-weight: 600; color: var(--primary-color); margin-left: 0.3rem;
            display: inline-block; min-width: 25px; text-align: right;
        }
        input[type="date"], textarea, input[type="number"] {
            width: 100%; padding: 0.8rem 1rem; border: 1px solid var(--border-color);
            border-radius: var(--radius-md); font-size: 1rem; transition: var(--transition);
            background-color: #fff; color: var(--text-color);
        }
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button { height: auto; }
        input[type="date"]:focus, textarea:focus, input[type="number"]:focus {
            outline: none; border-color: var(--border-focus);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
        }
        .form-note { font-size: 0.85rem; color: var(--text-muted); margin-top: 0.35rem; }

        /* Custom Range Slider Styles */
        input[type="range"] {
            width: 100%; height: 10px; -webkit-appearance: none; appearance: none;
            background: #e5e7eb; border-radius: var(--radius-sm); outline: none;
            margin: 10px 0; transition: var(--transition); cursor: pointer;
        }
        input[type="range"]:focus { box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2); }
        input[type="range"]::-webkit-slider-runnable-track {
            height: 10px;
            background: linear-gradient(to right, var(--secondary-color) 0%, var(--secondary-color) var(--value-percent, 0%), #e5e7eb var(--value-percent, 0%), #e5e7eb 100%);
            border-radius: var(--radius-sm);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 22px; height: 22px;
            background: var(--primary-color); border-radius: 50%; cursor: pointer;
            transition: var(--transition); border: 3px solid white;
            box-shadow: var(--shadow-sm); margin-top: -6px;
        }
        input[type="range"]::-moz-range-thumb {
            width: 22px; height: 22px; background: var(--primary-color);
            border-radius: 50%; cursor: pointer; border: 3px solid white;
            box-shadow: var(--shadow-sm);
        }
        input[type="range"]::-moz-range-track {
            height: 10px; background: #e5e7eb; border-radius: var(--radius-sm);
        }
        input[type="range"]::-moz-range-progress {
            background-color: var(--secondary-color); height: 10px;
            border-radius: var(--radius-sm);
        }
        textarea { resize: vertical; min-height: 120px; }

        /* ===================================
           Buttons & Interactive Elements
           =================================== */
        button.btn, .btn {
            display: inline-flex; 
            align-items: center; 
            justify-content: center;
            gap: 0.5rem; 
            padding: 0.8rem 1.5rem; 
            border: none;
            border-radius: var(--radius-md); 
            font-size: 1rem; 
            font-weight: 500;
            cursor: pointer; 
            transition: var(--transition); 
            text-align: center;
            position: relative;
        }
        button.btn-primary, .btn-primary {
            background-color: var(--primary-color); color: white;
        }
        button.btn-primary:hover:not(:disabled), .btn-primary:hover:not(:disabled) {
            background-color: var(--primary-hover); box-shadow: var(--shadow-sm);
        }
        button.btn-secondary, .btn-secondary {
            background-color: var(--bg-alt); color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        button.btn-secondary:hover:not(:disabled), .btn-secondary:hover:not(:disabled) {
            background-color: #f0f0f0; border-color: #d1d5db; color: var(--text-color);
        }
        button.btn-danger, .btn-danger {
            background-color: var(--danger-color); color: white;
        }
        button.btn-danger:hover:not(:disabled), .btn-danger:hover:not(:disabled) {
            background-color: var(--danger-hover); box-shadow: var(--shadow-sm);
        }
        button.btn:disabled, .btn:disabled {
            opacity: 0.6; cursor: not-allowed;
        }
        /* Specific button styles */
        .save-btn { width: 100%; }
        .form-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1rem; /* Add space above action buttons */
            flex-wrap: wrap; /* Wrap buttons on small screens */
        }
        .form-actions .save-btn { flex-grow: 1; } /* Allow save button to grow */
        .form-actions .clear-btn { flex-grow: 0; } /* Clear button takes minimum space */

        /* Loading state */
        .btn.loading::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: #ffffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .btn.loading > *:not(.sr-only) { /* Hide text/icon when loading */
            visibility: hidden;
        }
        @keyframes spin { to { transform: translate(-50%, -50%) rotate(360deg); } }

        /* --- Chart View Styles --- */
        .chart-controls {
            display: flex; flex-direction: column; gap: 1.25rem; margin-bottom: 1.5rem;
            padding: 1.25rem; background-color: #f3f4f6; border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
        }
        .week-nav {
            display: flex; align-items: center; justify-content: space-between;
            gap: 1rem; flex-wrap: wrap;
        }
        .view-options {
            display: flex; justify-content: center; gap: 0.75rem; flex-wrap: wrap;
        }
        .week-nav-label {
            font-weight: 600; min-width: 180px; text-align: center;
            color: var(--primary-color); background-color: #e0e7ff;
            padding: 0.5rem 1rem; border-radius: var(--radius-sm); flex-grow: 1;
            margin: 0.25rem 0;
        }
        .week-nav-btn, .view-options button {
            background-color: var(--bg-alt); color: var(--text-secondary);
            border: 1px solid var(--border-color); width: auto; padding: 0.6rem 1.2rem;
            height: auto; font-weight: 500;
        }
        
        /* Stile per i pulsanti disabilitati quando si è in modalità tabella domande */
        .view-options button.disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
        .week-nav-btn:hover:not(:disabled),
        .view-options button:hover:not(.active) {
            background-color: #f0f0f0; border-color: #d1d5db; color: var(--text-color);
        }
        .week-nav-btn:disabled { opacity: 0.6; cursor: not-allowed; background-color: #f9fafb; }
        .view-options button.active {
            background-color: var(--primary-color); color: white;
            border-color: var(--primary-color); box-shadow: var(--shadow-sm);
        }
        .chart-tabs {
            display: flex; margin-bottom: 1.5rem; border-bottom: 2px solid var(--border-color);
            padding-bottom: 0; flex-wrap: wrap;
        }
        .chart-tab {
            background: none; border: none; border-bottom: 3px solid transparent;
            padding: 0.75rem 1.25rem; margin-right: 0.5rem; margin-bottom: -2px;
            cursor: pointer; font-size: 1rem; border-radius: var(--radius-sm) var(--radius-sm) 0 0;
            color: var(--text-muted); transition: var(--transition); font-weight: 500;
        }
        .chart-tab:hover { background-color: #f3f4f6; color: var(--text-secondary); border-bottom-color: #d1d5db; }
        .chart-tab.active { color: var(--primary-color); font-weight: 600; border-bottom-color: var(--primary-color); }
        .chart-tab#tests-chart-tab-btn.active { color: var(--secondary-color); border-bottom-color: var(--secondary-color); }
        .chart-container {
            margin-top: 1.2rem; position: relative;
            transition: opacity 0.3s ease;
            height: 400px; /* Altezza media per garantire visibilità senza overflow */
            max-width: 100%;
        }
        
        /* Subtabs for MindTrack and Tests - FORZIAMO COLORI SCURI */
        .mindtrack-subtabs, .tests-subtabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0;
        }
        .mindtrack-subtab, .tests-subtab {
            background: none; 
            border: none; 
            border-bottom: 3px solid transparent;
            padding: 0.75rem 1.25rem; 
            margin-right: 0.5rem; 
            margin-bottom: -2px;
            cursor: pointer; 
            font-size: 1rem; 
            border-radius: var(--radius-sm) var(--radius-sm) 0 0;
            color: #4b5563 !important; /* Forziamo grigio scuro */
            transition: var(--transition); 
            font-weight: 500;
        }
        .mindtrack-subtab:hover, .tests-subtab:hover {
            background-color: #f3f4f6; 
            color: #1f2937 !important; /* Forziamo grigio più scuro */
            border-bottom-color: #d1d5db;
        }
        .mindtrack-subtab.active {
            color: #2563eb !important; /* Forziamo blu */
            font-weight: 600; 
            border-bottom-color: #2563eb;
        }
        .tests-subtab.active {
            color: #4f46e5 !important; /* Forziamo viola */
            font-weight: 600; 
            border-bottom-color: #4f46e5;
        }
        .test-selector {
            margin: 1rem 0;
            padding: 1rem;
            background-color: #f9fafb;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
        }
        .test-selector label {
            display: inline-block;
            margin-right: 0.75rem;
            color: var(--text-secondary);
            font-weight: 500;
        }
        .test-selector select {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            background-color: var(--bg-alt);
            color: var(--text-color);
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.95rem;
            font-weight: 500;
        }
        .test-selector select:hover {
            border-color: var(--border-focus);
        }
        .test-selector select:focus {
            outline: none;
            border-color: var(--border-focus);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
        }

        /* --- Diary View Styles (Unified) --- */
        .diary-list { display: flex; flex-direction: column; gap: 1.75rem; }
        
        /* Filter buttons for diary */
        .diary-filters {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        .diary-filter-btn {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-color);
            background-color: var(--bg-alt);
            color: var(--text-secondary);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.9rem;
            font-weight: 500;
        }
        .diary-filter-btn:hover {
            background-color: #f0f0f0;
            border-color: #d1d5db;
        }
        .diary-filter-btn.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        /* Entry card (MindTrack entries) */
        .entry-card {
            border: none; border-radius: var(--radius-lg);
            padding: 1.2rem; transition: var(--transition); background-color: var(--bg-alt);
            box-shadow: var(--shadow-sm);
            margin-bottom: 0.75rem;
        }
        .entry-card:hover { box-shadow: var(--shadow-md); transform: translateY(-2px); }
        .entry-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 1.25rem; font-weight: 600; color: var(--primary-color);
            border-bottom: 1px solid #f0f0f0; padding-bottom: 0.85rem;
        }
        .entry-header .date { font-size: 1.15rem; }
        .entry-header .type-badge {
            font-size: 0.85rem;
            background-color: var(--primary-color);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: var(--radius-sm);
            font-weight: 500;
        }
        .entry-actions button {
            background: none; border: none; color: var(--text-muted); cursor: pointer;
            padding: 0.4rem; margin-left: 0.6rem; font-size: 1.1rem; border-radius: 50%;
            width: 32px; height: 32px; display: inline-flex; align-items: center;
            justify-content: center; transition: var(--transition);
        }
        .entry-actions button:hover { color: var(--primary-color); background-color: #f3f4f6; }
        .entry-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 0.85rem 1.75rem; margin-bottom: 1.25rem;
        }
        .entry-item {
            font-size: 0.95rem; line-height: 1.5; display: flex; align-items: center; gap: 0.4rem;
        }
        .entry-item strong { color: #6b7280; font-weight: 500; }
        .entry-item span { color: var(--text-color); font-weight: 600; }
        .entry-notes {
            margin-top: 1rem; font-size: 0.95rem; line-height: 1.6;
            background-color: #f9fafb; padding: 0.8rem; border-radius: var(--radius-sm);
            border-left: 4px solid var(--secondary-color); color: var(--text-secondary);
        }
        .entry-notes-label {
            color: var(--text-color); font-weight: 600; display: block;
            margin-bottom: 0.4rem; font-size: 1rem;
        }
        .entry-notes p { margin: 0; }

        /* Test result card (Test results) */
        .test-result-card {
            border: none; border-radius: var(--radius-lg);
            padding: 1.2rem; transition: var(--transition); background-color: var(--bg-alt);
            box-shadow: var(--shadow-sm);
            margin-bottom: 0.75rem;
        }
         .test-result-card:hover { box-shadow: var(--shadow-md); }
        .test-result-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 1rem; font-weight: 600; color: var(--secondary-color);
            border-bottom: 1px solid #f0f0f0; padding-bottom: 0.75rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .test-result-header .test-name { font-size: 1.15rem; flex-grow: 1; }
        .test-result-header .test-date { font-size: 0.95rem; color: var(--text-muted); font-weight: 500; margin-right: 0.5rem; }
        .test-result-header .entry-actions { display: flex; align-items: center; }
        .test-result-header .type-badge {
            font-size: 0.85rem;
            background-color: var(--secondary-color);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: var(--radius-sm);
            font-weight: 500;
        }
        .test-result-body {
            margin-bottom: 1rem;
        }
         .test-result-body .total-score {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-color);
        }
         .test-result-body .total-score strong {
             color: var(--primary-color);
             font-size: 1.2em;
         }
        .test-result-details {
            margin-top: 0.8rem;
        }
        .test-result-details h4 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }
        .test-result-answers {
            font-size: 0.9em;
            color: var(--text-color);
            background-color: #f9fafb;
            padding: 0.8rem;
            border-radius: var(--radius-sm);
            border: 1px solid var(--info-border);
            max-width: 100%;
        }
        .test-answer {
            display: flex;
            justify-content: space-between;
            padding: 0.3rem 0;
            border-bottom: 1px dotted var(--border-color);
            margin-bottom: 0.3rem;
        }
        .test-answer:last-child {
            border-bottom: none;
        }
        .test-answer .question {
            flex-grow: 1;
            margin-right: 1rem;
            font-size: 0.95rem;
        }
        .test-answer .score {
            font-weight: 600;
            color: var(--primary-color);
        }
        .no-answers {
            color: var(--text-muted);
            font-style: italic;
            padding: 0.5rem 0;
            text-align: center;
        }
        .test-result-answers span {
            display: inline-block;
            white-space: nowrap;
            padding: 0.2rem 0.4rem;
            background-color: white;
            border: 1px solid #e5e7eb;
            border-radius: var(--radius-sm);
            font-size: 0.85rem;
        }
        
        /* Stili per la tabella di dettaglio dei test */
        .test-details-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.95rem;
            box-shadow: var(--shadow-sm);
            background-color: var(--bg-alt);
            table-layout: auto;
            min-width: 800px; /* Garantisce una larghezza minima per la tabella */
        }
        
        
        
        .test-details-table th, 
        .test-details-table td {
            border: 1px solid var(--border-color);
            padding: 0.75rem;
            text-align: left;
            white-space: normal; /* Permette a testo lungo di andare a capo */
        }
        
        /* Stile per la colonna domanda */
        .test-details-table th:first-child,
        .test-details-table td:first-child {
            min-width: 200px; /* Larghezza minima per la colonna domanda */
            max-width: 300px; /* Larghezza massima per evitare colonne troppo ampie */
        }
        
        /* Stile per le colonne date */
        .test-details-table th:not(:first-child):not(:last-child),
        .test-details-table td:not(:first-child):not(:last-child) {
            min-width: 80px; /* Larghezza minima per le colonne date */
            text-align: center; /* Centra il testo */
        }
        
        
        .test-details-table th {
            background-color: #f8fafc;
            font-weight: 600;
            color: var(--secondary-color);
        }
        
        .test-details-table tbody tr:nth-child(even) {
            background-color: #f9fafb;
        }
        
        .test-details-table tbody tr:hover {
            background-color: #f1f5f9;
        }
        
        .test-details-table .trend-cell {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .test-details-table .trend-indicator {
            font-size: 1.1rem;
        }
        
        .test-details-table .trend-up {
            color: #ef4444; /* Rosso - peggioramento */
        }
        
        .test-details-table .trend-down {
            color: #22c55e; /* Verde - miglioramento */
        }
        
        .test-details-table .trend-stable {
            color: #f59e0b; /* Arancione - stabile */
        }
        
        .test-details-container {
            width: 100%;
            margin-bottom: 2rem;
            display: none;
            overflow-x: auto; /* Consente scorrimento orizzontale se necessario */
            margin-top: 20px; /* Aggiunge un po' di spazio tra il grafico e la tabella */
            padding-bottom: 50px; /* Aggiunge spazio sotto la tabella */
        }
        
        

        /* --- Data Management View --- */
        .data-options { display: flex; flex-wrap: wrap; gap: 2rem; margin-bottom: 2.5rem; }
        .data-card {
            flex: 1 1 300px; background-color: var(--bg-alt); border-radius: var(--radius-lg);
            padding: 1.75rem; display: flex; flex-direction: column; align-items: center;
            text-align: center; box-shadow: var(--shadow-sm); border: 1px solid var(--border-color);
            transition: var(--transition);
        }
        .data-card:hover { transform: translateY(-4px); box-shadow: var(--shadow-md); }
        .data-icon { font-size: 3rem; margin-bottom: 1rem; color: var(--primary-color); }
        .data-card p { color: var(--text-muted); margin-bottom: 1.75rem; font-size: 0.95rem; line-height: 1.5; flex-grow: 1; }
        #import-btn-trigger { background-color: var(--primary-color); color: white; }
        #import-btn-trigger:hover:not(:disabled) { background-color: var(--primary-hover); }
        .data-info {
            background-color: var(--info-bg); border: 1px solid var(--info-border);
            border-radius: var(--radius-md); padding: 1.5rem; margin-top: 1rem;
        }
        .data-info p { color: #1e3a8a; font-size: 0.9rem; line-height: 1.5; }
        .data-info code {
            background-color: #dbeafe; padding: 0.1em 0.4em; border-radius: var(--radius-sm);
            font-family: monospace; font-size: 0.85em; color: #1e40af;
        }

        /* --- Take Test View Styles --- */
        .test-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        .test-card {
            background-color: var(--bg-alt);
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
            transition: var(--transition);
        }
        .test-card:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-md);
        }
        .test-card h3 {
            margin-bottom: 0.5rem;
            color: var(--secondary-color);
        }
        .test-card p {
            color: var(--text-muted);
            margin-bottom: 1.25rem;
            font-size: 0.9rem;
            flex-grow: 1;
        }
        .start-test-btn {
            margin-top: auto;
            background-color: var(--secondary-color);
            color: white;
        }
        .start-test-btn:hover:not(:disabled) {
            background-color: var(--secondary-hover);
        }
        .test-results-area {
            margin-top: 2rem;
            padding: 1.5rem;
            background-color: var(--info-bg);
            border: 1px solid var(--info-border);
            border-radius: var(--radius-md);
            display: none;
            tabindex: -1;
        }
        .test-results-area h3 {
            color: #1e40af;
            margin-bottom: 1rem;
        }
        .test-results-area p {
            font-size: 1.1rem;
            font-weight: 500;
            color: var(--text-color);
        }
        .test-results-area .disclaimer {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 1rem;
            font-style: italic;
        }

        /* --- Test Modal Styles --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center;
            align-items: center; z-index: 1000; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0s 0.3s linear;
        }
        .modal-overlay.visible { opacity: 1; visibility: visible; transition: opacity 0.3s ease; }
        .modal-content {
            background-color: var(--bg-alt); padding: 2rem; border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg); max-width: 600px; width: 90%; max-height: 90vh;
            overflow-y: auto; position: relative; transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        .modal-overlay.visible .modal-content { transform: scale(1); }
        .modal-header {
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid var(--border-color); padding-bottom: 1rem;
            margin-bottom: 1.5rem;
        }
        .modal-title { font-size: 1.3rem; font-weight: 600; color: var(--primary-color); }
        .modal-close-btn {
            background: none; border: none; font-size: 1.8rem; line-height: 1;
            color: var(--text-muted); cursor: pointer; padding: 0.25rem;
        }
        .modal-close-btn:hover { color: var(--text-color); }
        .modal-question-text { font-size: 1.1rem; margin-bottom: 1.5rem; line-height: 1.5; color: var(--text-secondary); }
        .modal-scoring { margin-bottom: 2rem; }
        .scoring-options {
            display: flex; justify-content: space-around; flex-wrap: wrap; gap: 1rem;
            padding: 1rem; background-color: #f9fafb; border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
        }
        .scoring-options label {
            display: flex; flex-direction: column; align-items: center; cursor: pointer;
            font-size: 0.95rem; color: var(--text-secondary); padding: 0.5rem;
            border-radius: var(--radius-sm); transition: background-color 0.2s ease;
            min-width: 60px; text-align: center;
        }
         .scoring-options input[type="radio"] {
            margin-bottom: 0.5rem; accent-color: var(--primary-color); width: 18px; height: 18px;
        }
        .scoring-options label:hover { background-color: #f0f0f0; }
         .scoring-options input[type="radio"]:checked + span { font-weight: 600; color: var(--primary-color); }
         .scoring-options input[type="radio"]:focus-visible + span { outline: 2px solid var(--primary-hover); outline-offset: 2px; border-radius: var(--radius-sm); }
        .modal-navigation {
            display: flex; justify-content: space-between; align-items: center;
            margin-top: 1.5rem; border-top: 1px solid var(--border-color); padding-top: 1.5rem;
        }
        .modal-progress { font-size: 0.9rem; color: var(--text-muted); }

        /* --- UI Messages (Success/Error) --- */
        .message {
            margin-top: 1.5rem; padding: 1rem 1.25rem; border-radius: var(--radius-md);
            font-size: 0.95rem; font-weight: 500; text-align: center;
            border: 1px solid transparent;
        }
        .message.success { background-color: var(--success-bg); color: var(--success-color); border-color: #6ee7b7; }
        .message.error { background-color: var(--error-bg); color: var(--error-color); border-color: #fca5a5; }

        /* --- Footer --- */
        footer {
            background-color: var(--bg-alt); padding: 1.5rem; text-align: center;
            color: var(--text-muted); font-size: 0.9rem; border-top: 1px solid var(--border-color);
            margin-top: auto; width: 100%;
        }

        /* --- Utility Classes --- */
        .empty-message {
            text-align: center; 
            color: var(--text-muted); 
            margin: 0;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.1rem; 
            font-style: italic; 
            padding: 2rem;
            width: 80%;
            max-width: 500px;
            background-color: #f9fafb; 
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            border: 1px dashed var(--border-color);
            z-index: 5;
        }
        
        /* Classe per spostare il messaggio di errore dei test più in basso */
        .test-empty-message-lower {
            top: calc(50% + 200px);
        }
        /* Stile specifico per il messaggio vuoto nel diario */
        #diary-empty-message {
            position: relative;
            top: auto;
            left: auto;
            transform: none;
            margin: 2rem auto;
            z-index: 1;
        }
        
        /* Stile specifico per il messaggio vuoto nei grafici MindTrack */
        #chart-empty-message {
            position: absolute;
            top: calc(50% + 200px); /* Spostato 200px più in basso rispetto al centro */
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        
        .empty-message strong { 
            display: block; 
            margin-bottom: 1rem; 
            font-style: normal; 
            color: var(--text-secondary);
            font-size: 1.3rem;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(15px); } to { opacity: 1; transform: translateY(0); } }
        .fade-in { animation: fadeIn 0.5s ease-out forwards; }
        .sr-only {
             position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px;
             overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0;
        }
        
        /* Stili per login modal */
        .login-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .login-modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            max-width: 400px;
            width: 100%;
        }
        
        .login-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 1.5rem;
        }
        
        #login-btn, #user-btn {
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
        }
        
        #user-btn {
            background-color: var(--primary-color);
            color: white;
        }
        
        
        .login-subtitle {
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 2.5rem;
            font-size: 1.1rem;
            line-height: 1.5;
            max-width: 90%;
        }
        
        .login-modal-content {
            width: 100%;
            padding: 1.5rem;
            border-radius: 12px;
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
        }
        
        .login-modal-content h2 {
            text-align: center;
            margin-bottom: 1rem;
            color: var(--text-color);
            font-size: 1.5rem;
        }
        
        .login-modal-content p {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
            font-size: 0.95rem;
        }
        
        .login-form .form-group {
            margin-bottom: 1.75rem;  /* Aumentato spazio tra i gruppi */
        }
        
        .login-form .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;  /* Font più bold */
            color: var(--text-color);
            font-size: 1.05rem;  /* Font più grande */
        }
        
        .login-form .form-group input {
            width: 100%;
            padding: 1rem 1.25rem;  /* Aumentato padding */
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            font-size: 1.1rem;  /* Aumentato font */
            transition: border-color 0.2s, box-shadow 0.2s;
            margin-top: 0.5rem;  /* Aggiunto margine */
        }
        
        .login-form .form-group input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            outline: none;
        }
        
        .login-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 2rem;
            gap: 1rem;
        }
        
        .login-buttons button {
            flex: 1;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 1rem;
        }
        
        .login-buttons button.btn-primary {
            background-color: var(--primary-color);
            border: none;
            color: white;
        }
        
        .login-buttons button.btn-primary:hover {
            background-color: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .login-buttons button.btn {
            background-color: white;
            border: 1px solid #cbd5e1;
            color: var(--text-color);
        }
        
        .login-buttons button.btn:hover {
            background-color: #f1f5f9;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        .skip-login {
            margin-top: 2rem;
            text-align: center;
            width: 100%;
            padding-top: 1.5rem;
            border-top: 1px solid #e2e8f0;
        }
        
        .text-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.9rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            transition: all 0.2s;
        }
        
        .text-btn:hover {
            color: var(--primary-color);
            background-color: rgba(37, 99, 235, 0.05);
        }
        
        #login-error {
            width: 100%;
            margin-bottom: 1rem;
            border-radius: 8px;
        }
        
        .btn-icon {
            display: inline-block;
            margin-right: 0.5rem;
            font-size: 1.1rem;
        }
        /* Improved Focus Outline */
        *:focus-visible {
            outline: 3px solid var(--primary-hover); outline-offset: 2px;
            box-shadow: 0 0 0 5px rgba(29, 78, 216, 0.2); border-radius: var(--radius-sm);
        }
        *:focus:not(:focus-visible) { outline: none; }
        input[type="range"]:focus-visible::-webkit-slider-thumb { box-shadow: 0 0 0 5px rgba(29, 78, 216, 0.3); }
        input[type="range"]:focus-visible::-moz-range-thumb { box-shadow: 0 0 0 5px rgba(29, 78, 216, 0.3); }

        /* ===================================
           Responsive Design - Mobile/Tablet
           =================================== */
        @media (max-width: 768px) {
            nav { 
                padding-right: 8rem;
            }
            nav button { padding: 0.5rem 0.8rem; font-size: 0.9rem; }
            .week-nav { flex-direction: column; align-items: stretch; }
            .week-nav-label { min-width: auto; margin-bottom: 0.75rem; font-size: 1rem; }
            .chart-tabs { justify-content: center; }
            .chart-tab { margin-bottom: 0.5rem; flex-grow: 1; text-align: center; }
            .entry-grid { grid-template-columns: 1fr; gap: 0.75rem; }
            .data-options { flex-direction: column; gap: 1.5rem; }
            .form-actions { flex-direction: column; }
            .form-actions .clear-btn { width: 100%; }
            .test-list { grid-template-columns: 1fr; }
        }
        @media (max-width: 480px) {
            .app-container { padding: 1rem 0.5rem; }
            .view-container { padding: 1rem; }
            h2 { font-size: 1.25rem; }
            button.btn, .btn, .week-nav-btn, .view-options button { padding: 0.7rem 1.2rem; font-size: 0.95rem; }
            .entry-header { flex-direction: column; align-items: flex-start; gap: 0.5rem; }
            .entry-actions { margin-left: 0; margin-top: 0.5rem; }
            .modal-content { padding: 1.5rem; width: 95%; }
            .modal-title { font-size: 1.15rem; }
            .modal-question-text { font-size: 1rem; }
            .scoring-options { padding: 0.75rem; }
            .scoring-options label { font-size: 0.9rem; min-width: 50px; }
            .modal-navigation { flex-direction: column; gap: 1rem; }
            .test-result-header { flex-direction: column; align-items: flex-start; }
        }
        
        /* --- Stili per la pagina di login --- */
        /* Stili del login page sono integrati nella classe .page */
        
        .login-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 450px;
            padding: 3.5rem;  /* Aumentato padding */
            background-color: white;
            box-shadow: 0 10px 25px rgba(37, 99, 235, 0.1);
            border-radius: var(--radius-lg);
            position: relative;
            transform: scale(0.95);  /* Ingrandito */
            transform-origin: center center;
            overflow: visible;
            border-top: 4px solid var(--primary-color);
            border-bottom: 4px solid var(--primary-color);
        }
        
        .login-title {
            font-size: 3.5rem;  /* Aumentato dimensione font */
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 1rem;  /* Aumentato margine */
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -1px;  /* Aggiunto spaziatura lettere */
        }
        
        .login-subtitle {
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-bottom: 2rem;
            text-align: center;
        }
        
        .login-form {
            width: 100%;
        }
        
        .login-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            width: 100%;
        }
        
        .login-buttons button {
            flex: 1;
        }
        
        .skip-login {
            margin-top: 2rem;
            text-align: center;
            width: 100%;
        }
        
        .text-btn {
            background-color: var(--primary-color);
            border: 2px solid var(--primary-color);
            color: white;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            padding: 1rem 2rem;
            border-radius: var(--radius-md);
            margin-top: 1.5rem;
            transition: var(--transition);
            box-shadow: var(--shadow-md);
            display: block;
            width: 100%;
            max-width: 300px;
            margin-left: auto;
            margin-right: auto;
            text-align: center;
            position: relative;
            z-index: 10;
        }
        
        .text-btn:hover {
            background-color: var(--primary-hover);
            color: white;
            transform: scale(1.05);
            box-shadow: var(--shadow-lg);
        }
        
        #login-error {
            margin-bottom: 1rem;
            display: none;
        }
        
        /* --- Vista delle Correlazioni --- */
        
        .correlation-filters {
            margin-bottom: 1.5rem;
            padding: 1.5rem;
            background-color: #f9fafb;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
        }
        
        .correlation-select {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: 1rem;
            margin-top: 0.5rem;
            background-color: white;
            cursor: pointer;
        }
        
        .correlation-select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            outline: none;
        }
        
        #custom-correlation {
            display: none;
            margin-top: 1rem;
            padding: 1rem;
            background-color: white;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
        }
        
        .correlation-axis {
            margin-bottom: 1rem;
        }
        
        .correlation-axis label {
            display: block;
            font-weight: 500;
            color: var(--text-color);
            margin-bottom: 0.5rem;
        }
        
        .correlation-chart-container {
            margin: 2rem 0;
            padding: 1rem;
            background-color: white;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
            display: flex;
            justify-content: center;
        }
        
        #correlation-chart {
            max-width: 100%;
            height: auto;
        }
        
        .correlation-statistics {
            margin: 2rem 0;
            padding: 1.5rem;
            background-color: #eff6ff;
            border-radius: var(--radius-md);
            border: 1px solid #93c5fd;
        }
        
        .correlation-statistics h3 {
            color: var(--primary-color);
            margin-bottom: 1rem;
            font-size: 1.3rem;
        }
        
        .correlation-statistics p {
            margin: 0.5rem 0;
            color: var(--text-color);
            font-size: 1rem;
        }
        
        .correlation-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
            flex-wrap: wrap;
        }
        
        .correlation-actions button {
            min-width: 200px;
        }
        
        @media (max-width: 768px) {
            .correlations-content {
                padding: 1.5rem;
            }
            
            .correlations-title {
                font-size: 2rem;
            }
            
            .correlation-actions {
                flex-direction: column;
            }
            
            .correlation-actions button {
                width: 100%;
            }
        }
    </style>
</head>
<body>

    
    <!-- Pagina di login -->
    <div id="login-page" class="page">
        <div class="login-content">
            <h1 class="login-title">MindTrack</h1>
            <p class="login-subtitle">Accedi per utilizzare MindTrack</p>
            
            <div id="login-error" class="message error"></div>
            
            <form id="login-form" class="login-form">
                <div class="form-group">
                    <label for="email">Nickname:</label>
                    <input type="text" id="email" required placeholder="Inserisci il tuo nickname">
                </div>
                
                <div class="form-group">
                    <label for="password">Password:</label>
                    <input type="password" id="password" required placeholder="Inserisci la tua password">
                </div>
                
                <div class="login-buttons" style="justify-content: center; margin-top: 2rem;">
                    <button type="submit" id="login-button" class="btn btn-primary" style="min-width: 220px; padding: 1rem 1.5rem; font-size: 1.1rem;">
                        <span class="btn-icon" style="font-size: 1.3rem;">🔐</span> Accedi
                    </button>
                </div>
            </form>
            
        </div>
    </div>

    <div id="intro-page" class="page">
        <div class="intro-content">
            <h1 class="intro-title">MindTrack</h1>
            <p class="intro-subtitle">Monitora e comprendi il tuo benessere mentale giorno per giorno.</p>
            <button id="start-app" class="start-btn" aria-label="Avvia l'applicazione MindTrack" onclick="startApp()">
                <span>&rarr;</span>
            </button>
        </div>
    </div>

    <div id="app-page" class="page">
        <header>
            <h1>MindTrack</h1>
        </header>

        <nav>
            <button id="form-btn" aria-label="Aggiungi nuovo MindTrack">
                <span>➕</span> Aggiungi
            </button>
            <button id="take-test-btn" aria-label="Accedi ai test psicologici">
                <span>📝</span> Fai un Test
            </button>
            <button id="chart-btn" aria-label="Visualizza grafici dei MindTrack">
                <span>📊</span> Grafici
            </button>
            <button id="correlations-btn" aria-label="Visualizza correlazioni">
                <span>📈</span> Correlazioni
            </button>
            <button id="diary-btn" aria-label="Visualizza diario unificato">
                <span>📔</span> Diario
            </button>
            <button id="data-btn" aria-label="Gestione dati, importa o esporta">
                <span>⚙️</span> Dati
            </button>
            <button id="user-btn" aria-label="Gestisci profilo" style="display: none;">
                <span>👤</span> <span id="user-email"></span>
            </button>
        </nav>

        <main class="app-container">
            <section id="form-view" class="view-container" aria-labelledby="form-view-title">
                <h2 id="form-view-title">Come ti senti oggi?</h2>
                <form id="entry-form">
                    <input type="hidden" id="editing-entry-id">
                    <div class="form-group">
                        <label for="date">Data:</label>
                        <input type="date" id="date" name="date" required aria-describedby="date-help">
                        <div id="date-help" class="form-note">Seleziona la data del MindTrack.</div>
                    </div>
                    <div class="form-group">
                        <label for="mood"><span class="emoji-label">😊</span> Umore: <span id="mood-value" class="slider-value">5</span>/10</label>
                        <input type="range" id="mood" name="mood" min="0" max="10" value="5" aria-valuetext="5 su 10">
                    </div>
                    <div class="form-group">
                        <label for="sleep"><span class="emoji-label">😴</span> Sonno: <span id="sleep-value" class="slider-value">5</span>/10</label>
                        <input type="range" id="sleep" name="sleep" min="0" max="10" value="5" aria-valuetext="5 su 10">
                    </div>
                    <div class="form-group">
                        <label for="energy"><span class="emoji-label">⚡</span> Energia: <span id="energy-value" class="slider-value">5</span>/10</label>
                        <input type="range" id="energy" name="energy" min="0" max="10" value="5" aria-valuetext="5 su 10">
                    </div>
                    <div class="form-group">
                        <label for="anxiety"><span class="emoji-label">😰</span> Ansia: <span id="anxiety-value" class="slider-value">5</span>/10</label>
                        <input type="range" id="anxiety" name="anxiety" min="0" max="10" value="5" aria-valuetext="5 su 10">
                    </div>
                    <div class="form-group">
                        <label for="dissociation"><span class="emoji-label">🫥</span> Dissociazione: <span id="dissociation-value" class="slider-value">5</span>/10</label>
                        <input type="range" id="dissociation" name="dissociation" min="0" max="10" value="5" aria-valuetext="5 su 10">
                    </div>
                     <div class="form-group">
                        <label for="boredom"><span class="emoji-label">😐</span> Noia: <span id="boredom-value" class="slider-value">5</span>/10</label>
                        <input type="range" id="boredom" name="boredom" min="0" max="10" value="5" aria-valuetext="5 su 10">
                    </div>
                    <div class="form-group">
                        <label for="steps"><span class="emoji-label">👣</span> Passi:</label>
                        <input type="number" id="steps" name="steps" min="0" value="0" placeholder="Es. 8500" aria-describedby="steps-help">
                        <div id="steps-help" class="form-note">Numero di passi fatti oggi.</div>
                    </div>
                    <div class="form-group">
                        <label for="phone-minutes"><span class="emoji-label">📱</span> Minuti al telefono:</label>
                        <input type="number" id="phone-minutes" name="phone-minutes" min="0" value="0" placeholder="Es. 45" aria-describedby="phone-minutes-help">
                        <div id="phone-minutes-help" class="form-note">Minuti totali di chiamate oggi.</div>
                    </div>
                    <div class="form-group">
                        <label for="km-run"><span class="emoji-label">🏃</span> Km corsi:</label>
                        <input type="number" id="km-run" name="km-run" min="0" step="0.1" value="0" placeholder="5.5" aria-describedby="km-run-help">
                        <div id="km-run-help" class="form-note">Chilometri corsi oggi.</div>
                    </div>
                    <div class="form-group">
                        <label for="notes">Note aggiuntive:</label>
                        <textarea id="notes" name="notes" placeholder="Cosa è successo oggi? Quali fattori hanno influenzato il tuo stato d'animo?" aria-describedby="notes-help"></textarea>
                        <div id="notes-help" class="form-note">Spazio per riflessioni, eventi significativi, o pensieri.</div>
                    </div>
                    <div class="form-actions">
                        <button type="submit" id="save-entry" class="btn btn-primary save-btn">
                            <span>💾</span> Salva MindTrack
                        </button>
                        <button type="button" id="clear-form-btn" class="btn btn-secondary clear-btn">
                            <span>🧹</span> Pulisci Modulo
                        </button>
                    </div>
                    <div id="form-message" class="message" style="display: none;" aria-live="polite"></div>
                </form>
            </section>

            <section id="chart-view" class="view-container" aria-labelledby="chart-view-title">
                <h2 id="chart-view-title">I tuoi dati nel tempo</h2>
                <div class="chart-controls">
                    <div class="week-nav">
                        <button id="prev-week" class="btn week-nav-btn" disabled aria-label="Settimana precedente">&laquo; Prec</button>
                        <div class="week-nav-label" id="week-label">Tutte le settimane</div>
                        <button id="next-week" class="btn week-nav-btn" disabled aria-label="Settimana successiva">Succ &raquo;</button>
                    </div>
                    <div class="view-options">
                        <button id="view-all-data" class="btn active" aria-label="Visualizza dati di tutte le settimane">Tutto</button>
                        <button id="view-current-week-data" class="btn" aria-label="Visualizza dati della settimana corrente">Sett. Corrente</button>
                    </div>
                </div>
                <div id="chart-tabs-container" class="chart-tabs" role="tablist" aria-label="Grafici disponibili">
                    <button id="mindtrack-chart-tab-btn" class="chart-tab active" role="tab" aria-selected="true" aria-controls="mindtrack-chart-container">MindTrack</button>
                    <button id="tests-chart-tab-btn" class="chart-tab" role="tab" aria-selected="false" aria-controls="tests-chart-container">Test</button>
                </div>
                
                <!-- SUBTABS FUORI DAI CONTAINER -->
                <div id="mindtrack-subtabs" class="mindtrack-subtabs">
                    <button class="mindtrack-subtab active" data-chart="mood">Parametri Emotivi</button>
                    <button class="mindtrack-subtab" data-chart="steps">Passi</button>
                    <button class="mindtrack-subtab" data-chart="phone">Min. Telefono</button>
                    <button class="mindtrack-subtab" data-chart="kmRun">Km Corsi</button>
                </div>
                
                <div id="tests-subtabs" class="tests-subtabs" style="display: none;">
                    <button class="tests-subtab active" data-view="totals">Punteggi Totali</button>
                    <button class="tests-subtab" data-view="table">Tabella Domande</button>
                </div>
                
                <div class="test-selector" id="test-selector" style="display: none;">
                    <label for="test-type-select">Seleziona Test:</label>
                    <select id="test-type-select">
                        <option value="all">Tutti i Test</option>
                        <option value="phq9">PHQ-9</option>
                        <option value="bdiii">BDI-II</option>
                        <option value="cesd">CES-D</option>
                        <option value="hads">HADS</option>
                        <option value="idssr30">IDS-SR30</option>
                    </select>
                </div>
                
                <!-- CHART CONTAINERS -->
                <div id="mindtrack-chart-container" class="chart-container" role="tabpanel" aria-labelledby="mindtrack-chart-tab-btn">
                    <canvas id="mindtrack-chart" aria-label="Grafico MindTrack"></canvas>
                </div>
                <div id="tests-chart-container" class="chart-container" style="display: none;" role="tabpanel" aria-labelledby="tests-chart-tab-btn" aria-hidden="true">
                    <canvas id="tests-chart" aria-label="Grafico Test Psicologici"></canvas>
                    <div id="test-details-container" class="test-details-container"></div>
                </div>
                <div id="chart-empty-message" class="empty-message" style="display: none;">
                    <strong>Nessun dato da visualizzare.</strong>
                    Aggiungi qualche MindTrack usando la scheda 'Aggiungi' per vedere i grafici.
                </div>
            </section>

            <section id="diary-view" class="view-container" aria-labelledby="diary-view-title">
                <h2 id="diary-view-title">Diario</h2>
                <div class="diary-filters">
                    <button id="filter-all" class="diary-filter-btn active" aria-label="Mostra tutti gli elementi">Tutto</button>
                    <button id="filter-mindtrack" class="diary-filter-btn" aria-label="Mostra solo MindTrack">MindTrack</button>
                    <button id="filter-tests" class="diary-filter-btn" aria-label="Mostra solo test">Test</button>
                </div>
                <div id="diary-list" class="diary-list" aria-live="polite"></div>
                <div id="diary-empty-message" class="empty-message" style="display: none;">
                    <strong>Il tuo diario è vuoto.</strong>
                    Inizia aggiungendo registrazioni o completando test.
                </div>
                <div id="diary-action-message" class="message" style="display: none;" aria-live="polite"></div>
            </section>

            <section id="take-test-view" class="view-container" aria-labelledby="take-test-view-title">
                <h2 id="take-test-view-title">Fai un Test Psicologico</h2>
                <div id="test-action-message" class="action-message" aria-live="polite" style="display: none;"></div>
                
                <div class="form-group" style="max-width: 300px; margin-bottom: 2rem;">
                    <label for="test-date">Data del test:</label>
                    <input type="date" id="test-date" name="test-date" aria-describedby="test-date-help">
                    <div id="test-date-help" class="form-note">Seleziona la data per il test.</div>
                </div>
                
                <p style="margin-bottom: 1.5rem; color: var(--text-muted);">Seleziona un test da compilare. Ricorda che questi test sono strumenti di autovalutazione e non sostituiscono una diagnosi professionale.</p>
                <div class="test-list" id="test-list-container"></div>
                <div id="test-results-area" class="test-results-area" tabindex="-1">
                    <h3 id="test-result-title">Risultato Test</h3>
                    <p id="test-result-score">Il tuo punteggio è: <strong>--</strong></p>
                    <p class="disclaimer">Nota: Questo punteggio è indicativo. Consulta un professionista della salute mentale per una valutazione completa e un'interpretazione accurata.</p>
                </div>
            </section>

            <section id="data-view" class="view-container" aria-labelledby="data-view-title">
                <h2 id="data-view-title">Gestione Dati</h2>
                <div class="data-options">
                    <div class="data-card">
                        <div class="data-icon">📤</div>
                        <h3>Esporta Dati</h3>
                        <p>Salva tutte le tue registrazioni MindTrack in un file CSV per backup o analisi esterne.</p>
                        <button id="export-btn" class="btn btn-primary" aria-busy="false">
                            <span>Esporta CSV</span>
                            <span class="sr-only">Esporta dati in formato CSV</span>
                        </button>
                        </div>
                    <div class="data-card">
                        <div class="data-icon">📥</div>
                        <h3>Importa Dati</h3>
                        <p>Carica registrazioni MindTrack da un file CSV. Assicurati che il file sia formattato correttamente.</p>
                        <input type="file" id="import-file" accept=".csv" style="display: none;" aria-label="Scegli file CSV da importare">
                        <button id="import-btn-trigger" class="btn btn-primary" aria-busy="false">
                            <span>Importa CSV</span>
                            <span class="sr-only">Importa dati da file CSV</span>
                         </button>
                    </div>
                </div>
                <div id="import-message" class="message" style="display: none;" aria-live="polite"></div>
            </section>
            
            <section id="correlations-view" class="view-container" aria-labelledby="correlations-view-title">
                <h2 id="correlations-view-title">Correlazioni MindTrack</h2>
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">Scopri le relazioni tra i vari aspetti del tuo benessere</p>
                
                <div class="correlation-filters">
                    <label for="correlation-type">Tipo di correlazione:</label>
                    <select id="correlation-type" class="correlation-select">
                        <option value="mood-sleep">Umore vs Sonno</option>
                        <option value="mood-energy">Umore vs Energia</option>
                        <option value="anxiety-sleep">Ansia vs Sonno</option>
                        <option value="energy-steps">Energia vs Passi</option>
                        <option value="phoneMinutes-anxiety">Telefono vs Ansia</option>
                        <option value="kmRun-energy">Km corsi vs Energia</option>
                        <option value="custom">Personalizzata</option>
                    </select>
                </div>
                
                <div id="custom-correlation" style="display: none;">
                    <div class="correlation-axis">
                        <label for="x-axis">Asse X:</label>
                        <select id="x-axis" class="correlation-select">
                            <option value="mood">Umore</option>
                            <option value="sleep">Sonno</option>
                            <option value="energy">Energia</option>
                            <option value="anxiety">Ansia</option>
                            <option value="dissociation">Dissociazione</option>
                            <option value="boredom">Noia</option>
                            <option value="steps">Passi</option>
                            <option value="phoneMinutes">Minuti telefono</option>
                            <option value="kmRun">Km corsi</option>
                        </select>
                    </div>
                    <div class="correlation-axis">
                        <label for="y-axis">Asse Y:</label>
                        <select id="y-axis" class="correlation-select">
                            <option value="mood">Umore</option>
                            <option value="sleep">Sonno</option>
                            <option value="energy">Energia</option>
                            <option value="anxiety">Ansia</option>
                            <option value="dissociation">Dissociazione</option>
                            <option value="boredom">Noia</option>
                            <option value="steps">Passi</option>
                            <option value="phoneMinutes">Minuti telefono</option>
                            <option value="kmRun">Km corsi</option>
                        </select>
                    </div>
                </div>
                
                <div class="correlation-chart-container">
                    <canvas id="correlation-chart" width="600" height="400"></canvas>
                </div>
                
                <div class="correlation-statistics">
                    <h3>Statistiche della correlazione</h3>
                    <p id="correlation-coefficient"></p>
                    <p id="correlation-interpretation"></p>
                    <p id="data-points-count"></p>
                </div>
                
                <div class="correlation-actions">
                    <button class="btn btn-primary" onclick="updateCorrelationChart()">
                        🔄 Aggiorna Grafico
                    </button>
                </div>
            </section>
        </main>

        <footer>
            I tuoi dati sono salvati localmente nel tuo browser e non vengono inviati a nessun server esterno.
        </footer>
    </div>

    <div id="test-modal-overlay" class="modal-overlay" aria-labelledby="test-modal-title" aria-modal="true" role="dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="test-modal-title" class="modal-title">Test</h3>
                <button id="test-modal-close-btn" class="modal-close-btn" aria-label="Chiudi test">&times;</button>
            </div>
            <div class="modal-body">
                <p id="test-modal-question" class="modal-question-text">Testo della domanda...</p>
                <div id="test-modal-scoring" class="modal-scoring" role="group" aria-labelledby="test-modal-question">
                     <div class="scoring-options">
                         <label>
                             <input type="radio" name="score" value="0" required>
                             <span>0</span>
                         </label>
                         <label>
                             <input type="radio" name="score" value="1">
                             <span>1</span>
                         </label>
                         <label>
                             <input type="radio" name="score" value="2">
                             <span>2</span>
                         </label>
                         <label>
                             <input type="radio" name="score" value="3">
                             <span>3</span>
                         </label>
                     </div>
                     <div id="score-error-message" class="message error" style="display: none; margin-top: 1rem; text-align: left; padding: 0.5rem 1rem; font-size: 0.9rem;">Seleziona un punteggio.</div>
                </div>
            </div>
            <div class="modal-navigation">
                <span id="test-modal-progress" class="modal-progress">Domanda 1 / N</span>
                <div>
                    <button id="test-modal-prev-btn" class="btn btn-secondary">Indietro</button>
                    <button id="test-modal-next-btn" class="btn btn-primary">Avanti</button>
                </div>
            </div>
        </div>
    </div>


    <script>
        /**
         * MindTrack - Applicazione per il monitoraggio del benessere mentale
         * Versione ottimizzata
         */
        
        async function salvaDatoRemoto(contenuto) {
          const res = await fetch(`${API_BASE}/salva`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ contenuto: JSON.stringify(contenuto) })
          });
          const json = await res.json();
          if (!json.ok) throw new Error(json.errore || 'Errore salvataggio');
        }

        async function caricaDatiRemoto() {
          const res = await fetch(`${API_BASE}/dati`);
          const dati = await res.json();
          return dati.map(item => item.contenuto);
        }
        
        // Funzione globale per navigare tra le pagine
        function navigateTo(pageId) {
            // Nascondi tutte le pagine
            document.getElementById('login-page').style.display = 'none';
            document.getElementById('intro-page').style.display = 'none';
            document.getElementById('app-page').style.display = 'none';
            
            // Mostra solo la pagina richiesta
            document.getElementById(pageId).style.display = 'flex';
            console.log('Navigazione a: ' + pageId);
        }
        
        function startApp() {
            // Prepara l'interfaccia dell'app
            document.querySelectorAll('.view-container').forEach(container => {
                container.style.display = 'none';
            });
            
            // Mostra la vista form come default
            document.getElementById('form-view').style.display = 'block';
            
            // Attiva il pulsante del form nella navigazione
            document.querySelectorAll('nav button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById('form-btn').classList.add('active');
            
            // Naviga alla pagina dell'app
            navigateTo('app-page');
        }
        
        // Aggiungiamo un semplice meccanismo di login
        document.addEventListener('DOMContentLoaded', function() {
            var loginForm = document.getElementById('login-form');
            if (loginForm) {
                loginForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    // Bypass autenticazione - accetta qualsiasi credenziale
                    navigateTo('intro-page');
                    return false;
                });
            }
        });
        
        document.addEventListener('DOMContentLoaded', async function() {
            'use strict';
            
            // Assicuriamoci che solo la pagina di login sia visibile all'inizio
            document.getElementById('login-page').style.display = 'flex';
            document.getElementById('intro-page').style.display = 'none';
            document.getElementById('app-page').style.display = 'none';
            
            // Assicuriamoci che la pagina dell'app sia inizializzata correttamente
            // Mostra la vista del form come default quando si accede all'app
            document.querySelectorAll('.view-container').forEach(container => {
                container.style.display = 'none';
            });
            document.getElementById('form-view').style.display = 'block';
            
            // Inizializza l'UI dell'app
            console.log("Inizializzazione UI dell'app...");
            
            // Aggiungi gli eventi per i pulsanti di navigazione
            document.querySelectorAll('nav button').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Rimuovi la classe active da tutti i pulsanti
                    document.querySelectorAll('nav button').forEach(b => b.classList.remove('active'));
                    
                    // Aggiungi la classe active al pulsante cliccato
                    this.classList.add('active');
                    
                    // Nascondi tutte le viste
                    document.querySelectorAll('.view-container').forEach(container => {
                        container.style.display = 'none';
                    });
                    
                    // Mostra la vista corrispondente
                    const viewId = this.id.replace('-btn', '-view');
                    const viewElement = document.getElementById(viewId);
                    if (viewElement) {
                        viewElement.style.display = 'block';
                    }
                });
            });

            // --- DOM Element References ---
            // Oggetto DOM per riferimenti ai componenti dell'app
            const DOM = {
                startAppBtn: document.getElementById('start-app'),
                nav: {
                    formBtn: document.getElementById('form-btn'),
                    chartBtn: document.getElementById('chart-btn'),
                    correlationsBtn: document.getElementById('correlations-btn'),
                    diaryBtn: document.getElementById('diary-btn'),
                    takeTestBtn: document.getElementById('take-test-btn'),
                    dataBtn: document.getElementById('data-btn'),
                    buttons: document.querySelectorAll('nav button')
                },
                views: {
                    form: document.getElementById('form-view'),
                    chart: document.getElementById('chart-view'),
                    correlations: document.getElementById('correlations-view'),
                    diary: document.getElementById('diary-view'),
                    takeTest: document.getElementById('take-test-view'),
                    data: document.getElementById('data-view'),
                    containers: document.querySelectorAll('.view-container')
                },
                form: {
                    formElement: document.getElementById('entry-form'),
                    editingEntryId: document.getElementById('editing-entry-id'),
                    dateInput: document.getElementById('date'),
                    moodInput: document.getElementById('mood'),
                    moodValueSpan: document.getElementById('mood-value'),
                    sleepInput: document.getElementById('sleep'),
                    sleepValueSpan: document.getElementById('sleep-value'),
                    energyInput: document.getElementById('energy'),
                    energyValueSpan: document.getElementById('energy-value'),
                    anxietyInput: document.getElementById('anxiety'),
                    anxietyValueSpan: document.getElementById('anxiety-value'),
                    dissociationInput: document.getElementById('dissociation'),
                    dissociationValueSpan: document.getElementById('dissociation-value'),
                    boredomInput: document.getElementById('boredom'),
                    boredomValueSpan: document.getElementById('boredom-value'),
                    stepsInput: document.getElementById('steps'),
                    phoneMinutesInput: document.getElementById('phone-minutes'),
                    kmRunInput: document.getElementById('km-run'),
                    notesInput: document.getElementById('notes'),
                    saveEntryBtn: document.getElementById('save-entry'),
                    clearFormBtn: document.getElementById('clear-form-btn'),
                    formMessage: document.getElementById('form-message'),
                    rangeInputs: document.querySelectorAll('#form-view input[type="range"]')
                },
                diary: {
                    diaryList: document.getElementById('diary-list'),
                    emptyMessage: document.getElementById('diary-empty-message'),
                    actionMessage: document.getElementById('diary-action-message'),
                    filterAllBtn: document.getElementById('filter-all'),
                    filterMindtrackBtn: document.getElementById('filter-mindtrack'),
                    filterTestsBtn: document.getElementById('filter-tests'),
                    filterButtons: document.querySelectorAll('.diary-filter-btn')
                },
                chart: {
                    chartTabsContainer: document.getElementById('chart-tabs-container'),
                    mindtrackChartTabBtn: document.getElementById('mindtrack-chart-tab-btn'),
                    testsChartTabBtn: document.getElementById('tests-chart-tab-btn'),
                    chartTabs: document.querySelectorAll('.chart-tab'),
                    mindtrackChartContainer: document.getElementById('mindtrack-chart-container'),
                    testsChartContainer: document.getElementById('tests-chart-container'),
                    chartContainers: document.querySelectorAll('.chart-container'),
                    mindtrackChartCanvas: document.getElementById('mindtrack-chart'),
                    testsChartCanvas: document.getElementById('tests-chart'),
                    chartEmptyMessage: document.getElementById('chart-empty-message'),
                    prevWeekBtn: document.getElementById('prev-week'),
                    nextWeekBtn: document.getElementById('next-week'),
                    weekLabel: document.getElementById('week-label'),
                    viewAllDataBtn: document.getElementById('view-all-data'),
                    viewCurrentWeekDataBtn: document.getElementById('view-current-week-data'),
                    viewOptionButtons: document.querySelectorAll('.view-options button'),
                    // New subtab elements
                    mindtrackSubtabs: document.querySelectorAll('.mindtrack-subtab'),
                    testsSubtabs: document.querySelectorAll('.tests-subtab'),
                    testTypeSelect: document.getElementById('test-type-select')
                },
                data: {
                    exportBtn: document.getElementById('export-btn'),
                    importBtnTrigger: document.getElementById('import-btn-trigger'),
                    importFileInput: document.getElementById('import-file'),
                    importMessage: document.getElementById('import-message')
                },
                takeTest: {
                    testDateInput: document.getElementById('test-date'),
                    testListContainer: document.getElementById('test-list-container'),
                    resultsArea: document.getElementById('test-results-area'),
                    resultTitle: document.getElementById('test-result-title'),
                    resultScore: document.getElementById('test-result-score'),
                    modalOverlay: document.getElementById('test-modal-overlay'),
                    modalTitle: document.getElementById('test-modal-title'),
                    modalCloseBtn: document.getElementById('test-modal-close-btn'),
                    modalQuestion: document.getElementById('test-modal-question'),
                    modalScoring: document.getElementById('test-modal-scoring'),
                    modalScoreOptions: document.querySelectorAll('input[name="score"]'),
                    modalScoreErrorMessage: document.getElementById('score-error-message'),
                    modalProgress: document.getElementById('test-modal-progress'),
                    modalPrevBtn: document.getElementById('test-modal-prev-btn'),
                    modalNextBtn: document.getElementById('test-modal-next-btn')
                }
            };

            // --- Application State ---
            let appState = {
                entries: [],
                testResults: [],
                activeView: 'form',
                activeChartView: 'mindtrack', // Changed from 'mood'
                activeMindtrackChart: 'mood',
                activeTestView: 'totals',
                selectedTest: 'all',
                chartInstances: { mindtrack: null, tests: null },
                currentWeekOffset: 0,
                weeksData: [],
                chartViewMode: 'all',
                currentTest: {
                    id: null, name: null, questions: [], scores: [], currentIndex: 0
                },
                diaryFilter: 'all'
            };

            // --- Constants ---
            const ENTRY_STORAGE_KEY = 'mindTrackEntries_v2';
            const TEST_RESULTS_STORAGE_KEY = 'mindTrackTestResults_v1';
            const MOOD_EMOJIS = ['😭', '😢', '🙁', '😐', '🙂', '😊', '😄', '😁', '🤩', '🥳', '🤯'];
            const SLIDER_MAP = [
                { input: DOM.form.moodInput, valueEl: DOM.form.moodValueSpan, emoji: true },
                { input: DOM.form.sleepInput, valueEl: DOM.form.sleepValueSpan },
                { input: DOM.form.energyInput, valueEl: DOM.form.energyValueSpan },
                { input: DOM.form.anxietyInput, valueEl: DOM.form.anxietyValueSpan },
                { input: DOM.form.dissociationInput, valueEl: DOM.form.dissociationValueSpan },
                { input: DOM.form.boredomInput, valueEl: DOM.form.boredomValueSpan },
            ];
            const TESTS_DATA = {
                phq9: { 
                    id: 'phq9', 
                    name: "PHQ-9", 
                    numQuestions: 9, 
                    questions: [
                        "PHQ-9 - Domanda 1: Anedonia",
                        "PHQ-9 - Domanda 2: Umore",
                        "PHQ-9 - Domanda 3: Sonno",
                        "PHQ-9 - Domanda 4: Energia",
                        "PHQ-9 - Domanda 5: Appetito",
                        "PHQ-9 - Domanda 6: Autostima",
                        "PHQ-9 - Domanda 7: Concentrazione",
                        "PHQ-9 - Domanda 8: Psicomotorio",
                        "PHQ-9 - Domanda 9: Suicidio"
                    ]
                },
                bdiii: { 
                    id: 'bdiii', 
                    name: "BDI-II", 
                    numQuestions: 21, 
                    questions: [
                        "BDI-II - Domanda 1: Tristezza",
                        "BDI-II - Domanda 2: Futuro",
                        "BDI-II - Domanda 3: Fallimento",
                        "BDI-II - Domanda 4: Piacere",
                        "BDI-II - Domanda 5: Colpa",
                        "BDI-II - Domanda 6: Punizione",
                        "BDI-II - Domanda 7: Delusione",
                        "BDI-II - Domanda 8: Autocritica",
                        "BDI-II - Domanda 9: Suicidio",
                        "BDI-II - Domanda 10: Pianto",
                        "BDI-II - Domanda 11: Irritabilità",
                        "BDI-II - Domanda 12: Interesse",
                        "BDI-II - Domanda 13: Decisioni",
                        "BDI-II - Domanda 14: Aspetto",
                        "BDI-II - Domanda 15: Lavoro",
                        "BDI-II - Domanda 16: Sonno",
                        "BDI-II - Domanda 17: Stanchezza",
                        "BDI-II - Domanda 18: Appetito",
                        "BDI-II - Domanda 19: Peso",
                        "BDI-II - Domanda 20: Salute",
                        "BDI-II - Domanda 21: Sesso"
                    ]
                },
                cesd: { 
                    id: 'cesd', 
                    name: "CES-D", 
                    numQuestions: 20, 
                    questions: [
                        "CES-D - Domanda 1: Fastidio",
                        "CES-D - Domanda 2: Appetito",
                        "CES-D - Domanda 3: Tristezza",
                        "CES-D - Domanda 4: Valore",
                        "CES-D - Domanda 5: Concentrazione",
                        "CES-D - Domanda 6: Depressione",
                        "CES-D - Domanda 7: Sforzo",
                        "CES-D - Domanda 8: Speranza",
                        "CES-D - Domanda 9: Fallimento",
                        "CES-D - Domanda 10: Paura",
                        "CES-D - Domanda 11: Sonno",
                        "CES-D - Domanda 12: Felicità",
                        "CES-D - Domanda 13: Silenzio",
                        "CES-D - Domanda 14: Solitudine",
                        "CES-D - Domanda 15: Ostilità",
                        "CES-D - Domanda 16: Vita",
                        "CES-D - Domanda 17: Pianto",
                        "CES-D - Domanda 18: Tristezza",
                        "CES-D - Domanda 19: Antipatia",
                        "CES-D - Domanda 20: Motivazione"
                    ]
                },
                hads: { 
                    id: 'hads', 
                    name: "HADS", 
                    numQuestions: 14, 
                    questions: [
                        "HADS - Domanda 1: Tensione",
                        "HADS - Domanda 2: Piacere",
                        "HADS - Domanda 3: Paura",
                        "HADS - Domanda 4: Risata",
                        "HADS - Domanda 5: Preoccupazioni",
                        "HADS - Domanda 6: Allegria",
                        "HADS - Domanda 7: Rilassamento",
                        "HADS - Domanda 8: Lentezza",
                        "HADS - Domanda 9: Farfalle",
                        "HADS - Domanda 10: Aspetto",
                        "HADS - Domanda 11: Irrequietezza",
                        "HADS - Domanda 12: Aspettativa",
                        "HADS - Domanda 13: Panico",
                        "HADS - Domanda 14: Svago"
                    ]
                },
                idssr30: { 
                    id: 'idssr30', 
                    name: "IDS-SR30", 
                    numQuestions: 30, 
                    questions: [
                        "IDS-SR30 - Domanda 1: Sonno",
                        "IDS-SR30 - Domanda 2: Risveglio",
                        "IDS-SR30 - Domanda 3: Alba",
                        "IDS-SR30 - Domanda 4: Eccesso",
                        "IDS-SR30 - Domanda 5: Tristezza",
                        "IDS-SR30 - Domanda 6: Irritabilità",
                        "IDS-SR30 - Domanda 7: Ansia",
                        "IDS-SR30 - Domanda 8: Reattività",
                        "IDS-SR30 - Domanda 9: Qualità",
                        "IDS-SR30 - Domanda 10: Variazione",
                        "IDS-SR30 - Domanda 11: Inappetenza",
                        "IDS-SR30 - Domanda 12: Fame",
                        "IDS-SR30 - Domanda 13: Dimagrimento",
                        "IDS-SR30 - Domanda 14: Ingrassamento",
                        "IDS-SR30 - Domanda 15: Concentrazione",
                        "IDS-SR30 - Domanda 16: Autostima",
                        "IDS-SR30 - Domanda 17: Futuro",
                        "IDS-SR30 - Domanda 18: Suicidio",
                        "IDS-SR30 - Domanda 19: Interesse",
                        "IDS-SR30 - Domanda 20: Energia",
                        "IDS-SR30 - Domanda 21: Piacere",
                        "IDS-SR30 - Domanda 22: Sesso",
                        "IDS-SR30 - Domanda 23: Rallentamento",
                        "IDS-SR30 - Domanda 24: Agitazione",
                        "IDS-SR30 - Domanda 25: Somatici",
                        "IDS-SR30 - Domanda 26: Panico",
                        "IDS-SR30 - Domanda 27: Gastrointestinali",
                        "IDS-SR30 - Domanda 28: Dolore",
                        "IDS-SR30 - Domanda 29: Simpatici",
                        "IDS-SR30 - Domanda 30: Sensibilità"
                    ]
                }
            };


            // --- Utility Functions ---
            const formatDateISO = (date) => {
                if (!(date instanceof Date)) { date = new Date(date); }
                return !isNaN(date) ? date.toISOString().split('T')[0] : '';
            };
            const formatDateForDisplay = (dateString) => {
                if (!dateString || !/^\d{4}-\d{2}-\d{2}$/.test(dateString)) return 'N/D';
                const [year, month, day] = dateString.split('-');
                return `${day}/${month}/${year}`;
            };
             const formatDateTimeForDisplay = (isoString) => {
                try {
                    const date = new Date(isoString);
                    if (isNaN(date)) return 'N/D';
                    // Solo la parte della data, senza ora
                    return date.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit', year: 'numeric' });
                } catch (e) {
                    return 'N/D';
                }
            };
            function getStartOfWeek(date, offsetWeeks = 0) {
                const d = new Date(date);
                d.setDate(d.getDate() + offsetWeeks * 7);
                const day = d.getDay(); const diff = d.getDate() - day + (day === 0 ? -6 : 1);
                return new Date(d.setDate(diff));
            }
            function showUIMessage(element, message, type = 'success', duration = 3000) {
                if (!element) return;
                element.innerHTML = message; element.className = `message ${type}`;
                element.style.display = 'block';
                element.setAttribute('role', type === 'error' ? 'alert' : 'status');
                if (element.timeoutId) { clearTimeout(element.timeoutId); }
                if (duration > 0) {
                    element.timeoutId = setTimeout(() => {
                        element.style.display = 'none'; element.timeoutId = null;
                    }, duration);
                }
            }
            function updateSliderVisuals(inputElement, valueElement, updateEmoji = false) {
                const value = parseInt(inputElement.value, 10); const max = parseInt(inputElement.max, 10) || 10;
                valueElement.textContent = value; inputElement.setAttribute('aria-valuetext', `${value} su ${max}`);
                if (updateEmoji && inputElement.id === 'mood') {
                    const emojiLabel = inputElement.previousElementSibling?.querySelector('.emoji-label');
                    if (emojiLabel) emojiLabel.textContent = MOOD_EMOJIS[value] || '😐';
                }
                const percent = (value / max) * 100; inputElement.style.setProperty('--value-percent', `${percent}%`);
            }
            function setButtonLoadingState(button, isLoading) {
                if (!button) return;
                button.classList.toggle('loading', isLoading); button.disabled = isLoading;
                button.setAttribute('aria-busy', isLoading ? 'true' : 'false');
            }


            // --- Data Persistence (LocalStorage) ---
             /**
              * Carica le voci del diario dal server remoto
              * Normalizza i dati e li prepara per l'uso nell'app
              */
             async function loadEntries() {
                try {
                    // Carica i dati dal server remoto
                    const res = await fetch(`${API_BASE}/dati`);
                    const datiRemoti = await res.json(); 
                    if (datiRemoti.length > 0) {
                      // prendo l'ultimo salvataggio, che contiene l'array completo
                      appState.entries = JSON.parse(datiRemoti[datiRemoti.length - 1].contenuto);
                    } else {
                      appState.entries = [];
                    }
                } catch (error) { 
                    console.error("Error loading entries:", error); 
                    appState.entries = [];
                }
                
                // Aggiorna i dati per settimana
                populateWeeksData();
            }
             /**
              * Salva le voci del diario nel server remoto e localmente come backup
              * Aggiorna anche l'interfaccia utente
              */
             async function refreshUI() {
                // Aggiorna i componenti dell'interfaccia utente
                populateWeeksData(); // Aggiorna dati per settimana
                updateCharts();      // Aggiorna grafici
                renderDiary();       // Aggiorna lista diario
             }
             
             async function saveEntries() {
                try {
                    // Segna tutte le voci come non sincronizzate per la sincronizzazione cloud
                    appState.entries.forEach(entry => {
                        entry.synced = false;
                    });
                    
                    // Ordina per data prima di salvare
                    appState.entries.sort((a, b) => new Date(a.date) - new Date(b.date));
                    
                    // Salva al server remoto
                    await salvaDatoRemoto(appState.entries);
                    
                    // Aggiorna l'interfaccia utente
                    await refreshUI();
                } catch (error) { 
                    console.error("Error saving entries:", error); 
                    showUIMessage(DOM.form.formMessage, "Errore salvataggio remoto.", "error");
                }
            }
             async function loadTestResults() {
                try {
                    console.log("=== INIZIO loadTestResults ===");
                    console.log("Test attuali in appState:", appState.testResults.length);
                    
                    // Prova prima a caricare dal localStorage come backup
                    let localDataLoaded = false;
                    
                    try {
                        const storedResults = localStorage.getItem(TEST_RESULTS_STORAGE_KEY);
                        if (storedResults) {
                            console.log("Tentativo di caricamento dati test da localStorage");
                            const parsedResults = JSON.parse(storedResults);
                            
                            // Normalizza i dati che potrebbero essere array di test
                            let validLocalResults = [];
                            
                            // Primo passo: gestisci possibili array
                            for (let item of parsedResults) {
                                if (Array.isArray(item) && item.length > 0) {
                                    validLocalResults.push(...item);
                                } else {
                                    validLocalResults.push(item);
                                }
                            }
                            
                            // Assicurati che ogni test locale abbia un ID
                            validLocalResults = validLocalResults.map(result => {
                                if (result && !result.id && result.testId) {
                                    result.id = `generated_${result.testId}_${Date.now()}_${Math.floor(Math.random() * 10000)}`;
                                }
                                return result;
                            });
                            
                            // Filtra per validità
                            validLocalResults = validLocalResults.filter(result => {
                                return result && 
                                    result.testId && 
                                    result.testName && 
                                    result.completionDate && 
                                    result.totalScore !== undefined;
                            });
                            
                            if (validLocalResults.length > 0) {
                                console.log(`Trovati ${validLocalResults.length} test validi nel localStorage`);
                                appState.testResults = validLocalResults;
                                localDataLoaded = true;
                            }
                        }
                    } catch (localError) {
                        console.error("Errore nel caricamento dei test dal localStorage:", localError);
                    }
                
                    // Carica i risultati dei test dal server remoto
                    let rawResults = [];
                    
                    // Prima prova a caricare dal localStorage
                    if (!localDataLoaded) {
                        // Prova quindi a caricare dal server
                        try {
                            // Prova prima l'endpoint specifico /tests 
                            console.log("Carico i test dall'endpoint /tests");
                            const res = await fetch(`${API_BASE}/tests`);
                            if (!res.ok) {
                                throw new Error(`Server error: ${res.status}`);
                            }
                            
                            const testData = await res.json();
                            if (!testData || testData.length === 0) {
                                console.log("Nessun test trovato nell'endpoint /tests");
                                appState.testResults = [];
                                return;
                            }
                            
                            // L'endpoint /tests restituisce [{ contenuto: JSON.stringify(testResults) }]
                            // Estrai i test dal primo elemento
                            if (testData.length > 0 && testData[0].contenuto) {
                                try {
                                    rawResults = JSON.parse(testData[0].contenuto);
                                    console.log(`Trovati ${rawResults.length} test dall'endpoint /tests`);
                                    
                                    // Controlla se ci sono duplicati dall'API
                                    const apiIds = rawResults.map(t => t.id);
                                    const uniqueApiIds = [...new Set(apiIds)];
                                    if (apiIds.length !== uniqueApiIds.length) {
                                        console.error("ATTENZIONE: L'API restituisce test duplicati!");
                                        console.log("Test dall'API:", apiIds.length, "Test unici:", uniqueApiIds.length);
                                        
                                        // Rimuovi i duplicati tenendo solo il primo di ogni ID
                                        const uniqueTests = [];
                                        const seenIds = new Set();
                                        for (const test of rawResults) {
                                            if (!seenIds.has(test.id)) {
                                                uniqueTests.push(test);
                                                seenIds.add(test.id);
                                            }
                                        }
                                        rawResults = uniqueTests;
                                        console.log(`Rimossi duplicati: ${rawResults.length} test unici`);
                                    }
                                } catch (parseError) {
                                    console.error("Errore nel parsing dei test dall'endpoint /tests:", parseError);
                                    throw parseError;
                                }
                            } else {
                                console.log("Formato dati non valido dall'endpoint /tests");
                                appState.testResults = [];
                                return;
                            }
                        } catch (apiError) {
                            console.error("Errore nel caricamento dei test dall'endpoint /tests:", apiError);
                            console.log("Provo con l'endpoint generico /dati come fallback");
                            
                            // Fallback all'endpoint generico
                            try {
                                const res = await fetch(`${API_BASE}/dati`);
                                if (!res.ok) {
                                    throw new Error(`Server error: ${res.status}`);
                                }
                                
                                const allData = await res.json();
                                if (!allData || allData.length === 0) {
                                    console.log("Nessun dato trovato nell'API generico");
                                    appState.testResults = [];
                                    return;
                                }
                                
                                // Cerca l'ultimo record che contiene i test
                                let foundTestData = false;
                                for (let i = allData.length - 1; i >= 0; i--) {
                                    try {
                                        const parsed = JSON.parse(allData[i].contenuto);
                                        if (Array.isArray(parsed) && parsed.length > 0 && parsed[0].testId) {
                                            rawResults = parsed;
                                            foundTestData = true;
                                            console.log(`Trovati ${parsed.length} test nell'API generico`);
                                            break;
                                        }
                                    } catch(e) {
                                        continue;
                                    }
                                }
                                
                                if (!foundTestData) {
                                    console.log("Nessun test trovato nei dati API generico");
                                    if (!localDataLoaded) {
                                        appState.testResults = [];
                                    }
                                    return;
                                }
                            } catch (fallbackError) {
                                console.error("Errore anche nel fallback API generico:", fallbackError);
                                if (!localDataLoaded) {
                                    appState.testResults = [];
                                }
                                return;
                            }
                        }
                    }
                    
                    // A questo punto abbiamo i dati o dal localStorage o dall'API
                    // Filtra i risultati per assicurarsi che contengano tutti i campi necessari
                    let validTestResults = [];
                    
                    // Solo se abbiamo raw results dal server e non abbiamo già caricato dal localStorage
                    if (rawResults.length > 0 && !localDataLoaded) {
                        // Primo passo: normalizza i dati che potrebbero essere array di test
                        for (let item of rawResults) {
                            // Se l'elemento è un array di test (situazione trovata nei dati importati)
                            if (Array.isArray(item) && item.length > 0) {
                                // Aggiungi ogni test nell'array come un elemento separato
                                validTestResults.push(...item);
                            } else {
                                // Altrimenti aggiungi l'elemento come test singolo
                                validTestResults.push(item);
                            }
                        }
                        
                        // Assicurati che ogni test abbia un ID
                        validTestResults = validTestResults.map(result => {
                            if (result && !result.id && result.testId) {
                                // Genera un ID univoco se mancante
                                result.id = `generated_${result.testId}_${Date.now()}_${Math.floor(Math.random() * 10000)}`;
                            }
                            return result;
                        });
                        
                        // Secondo passo: filtra i test per validità
                        validTestResults = validTestResults.filter(result => {
                            // Verifica che il test abbia tutti i campi obbligatori
                            const isValid = result && 
                                result.testId && 
                                result.testName && 
                                result.completionDate && 
                                result.totalScore !== undefined;
                                
                            if (!isValid) {
                                console.warn("Test result skipped due to missing required fields:", result);
                            }
                            
                            return isValid;
                        });
                        
                        if (validTestResults.length > 0) {
                            // Solo se abbiamo trovato test validi, aggiorniamo l'app state
                            console.log(`Trovati ${validTestResults.length} test validi dal server`);
                            appState.testResults = validTestResults;
                            
                            // Pulisci i dati corrotti e correggi i dati ove possibile
                            appState.testResults = appState.testResults.map(result => {
                                if (result.testId && TESTS_DATA[result.testId]) {
                                    const testData = TESTS_DATA[result.testId];
                                    
                                    // Assicurati che individualScores sia un array valido
                                    if (!Array.isArray(result.individualScores)) {
                                        result.individualScores = [];
                                    }
                                    
                                    // Assicurati che individualScores non sia più lungo del necessario
                                    if (result.individualScores.length > testData.numQuestions) {
                                        // Tronca l'array alla lunghezza corretta
                                        result.individualScores = result.individualScores.slice(0, testData.numQuestions);
                                    }
                            
                                    // Se totalScore è mancante o non valido, ricalcola
                                    if (result.totalScore === undefined || isNaN(result.totalScore)) {
                                        result.totalScore = result.individualScores.reduce((sum, score) => sum + (Number(score) || 0), 0);
                                    }
                                }
                                return result;
                            });
                            
                            appState.testResults.sort((a, b) => new Date(b.completionDate) - new Date(a.completionDate));
                            console.log(`Caricati ${appState.testResults.length} test dal server`);
                            
                            // Salva anche in localStorage come backup
                            try {
                                localStorage.setItem(TEST_RESULTS_STORAGE_KEY, JSON.stringify(appState.testResults));
                            } catch (localSaveError) {
                                console.error("Errore nel salvataggio dei test in localStorage:", localSaveError);
                            }
                        } else {
                            console.log("Nessun test valido trovato nei dati del server");
                        }
                    } else if (!localDataLoaded) {
                        console.log("Non ci sono dati da caricare, inizializzo con array vuoto");
                        appState.testResults = [];
                    }
                    
                    console.log(`Totale test caricati: ${appState.testResults.length}`);
                    
                    // Pulisci automaticamente i duplicati dopo il caricamento
                    await cleanupDuplicateTests();
                    
                    console.log("=== FINE loadTestResults ===");
                } catch (error) {
                    console.error("Error loading test results:", error);
                    
                    // Se i dati sono già stati caricati dal localStorage, non li cancellare
                    if (!localDataLoaded) {
                        console.log("Nessun dato è stato caricato, mantenendo l'array vuoto");
                        appState.testResults = [];
                    } else {
                        console.log("Mantenuti i dati caricati dal localStorage");
                    }
                }
                
                // Salva sempre i dati nel localStorage, anche se sono stati caricati solo da lì
                // Questo garantisce che non vengano persi dopo la cancellazione della cronologia
                try {
                    if (appState.testResults.length > 0) {
                        localStorage.setItem(TEST_RESULTS_STORAGE_KEY, JSON.stringify(appState.testResults));
                        console.log(`Salvati ${appState.testResults.length} test nel localStorage per backup`);
                    }
                } catch (saveError) {
                    console.error("Errore nel salvataggio dei test in localStorage:", saveError);
                }
            }
             async function saveTestResults() {
                try {
                    // Segna come non sincronizzati
                    appState.testResults.forEach(result => {
                        result.synced = false;
                    });
                    
                    // Ordina i risultati
                    appState.testResults.sort((a, b) => new Date(b.completionDate) - new Date(a.completionDate));
                    
                    // Usa saveTestResultsLocally che salva correttamente i dati
                    return saveTestResultsLocally();
                } catch (error) {
                    console.error("Error saving test results:", error);
                    showUIMessage(DOM.diary.actionMessage, "Errore nel salvataggio remoto dei test.", "error");
                    
                    // Tenta comunque il salvataggio locale
                    try {
                        localStorage.setItem(TEST_RESULTS_STORAGE_KEY, JSON.stringify(appState.testResults));
                        console.log("Saved test results to local storage as backup");
                    } catch (localError) {
                        console.error("Error saving test results to local storage:", localError);
                    }
                }
            }

            // --- Pulizia duplicati ---
            async function cleanupDuplicateTests() {
                console.log("=== INIZIO cleanupDuplicateTests ===");
                const originalCount = appState.testResults.length;
                
                if (originalCount === 0) {
                    console.log("Nessun test da pulire");
                    return;
                }
                
                // Raggruppa i test per testId (phq9, bdiii, etc.)
                const testGroups = {};
                
                appState.testResults.forEach(test => {
                    const testType = test.testId;
                    if (!testGroups[testType]) {
                        testGroups[testType] = [];
                    }
                    testGroups[testType].push(test);
                });
                
                // Per ogni gruppo, mantieni solo il test più recente (basato sull'ID che contiene timestamp)
                const uniqueTests = [];
                let duplicatesFound = false;
                
                Object.keys(testGroups).forEach(testType => {
                    const tests = testGroups[testType];
                    
                    if (tests.length > 1) {
                        duplicatesFound = true;
                        console.log(`Trovati ${tests.length} duplicati per ${testType}`);
                        
                        // Ordina per timestamp nell'ID (più recente prima)
                        tests.sort((a, b) => {
                            // Estrai il timestamp dall'ID (es: imported_phq9_1747859326199_9125)
                            const timestampA = parseInt(a.id.split('_')[2]) || 0;
                            const timestampB = parseInt(b.id.split('_')[2]) || 0;
                            return timestampB - timestampA; // Ordine decrescente
                        });
                        
                        // Mantieni solo il primo (più recente)
                        uniqueTests.push(tests[0]);
                        console.log(`Mantenuto ${testType} con ID: ${tests[0].id}`);
                    } else {
                        // Nessun duplicato, mantieni il test
                        uniqueTests.push(tests[0]);
                    }
                });
                
                if (duplicatesFound) {
                    console.log(`Pulizia completata: ${originalCount} → ${uniqueTests.length} test`);
                    appState.testResults = uniqueTests;
                    
                    // Salva i dati puliti
                    try {
                        await saveTestResultsLocally();
                        console.log("Test puliti salvati con successo");
                    } catch (error) {
                        console.error("Errore nel salvataggio dei test puliti:", error);
                    }
                } else {
                    console.log("Nessun duplicato trovato");
                }
                
                console.log("=== FINE cleanupDuplicateTests ===");
            }


            // --- Form Handling ---
             function resetForm(focusDate = true) {
                DOM.form.formElement.reset(); DOM.form.editingEntryId.value = '';
                
                // Assicuriamo di usare la data corretta (es. 14/05 e non 13/05)
                const today = new Date();
                today.setHours(12, 0, 0, 0); // Impostiamo a mezzogiorno per evitare problemi di timezone
                DOM.form.dateInput.value = formatDateISO(today);
                
                SLIDER_MAP.forEach(({ input, valueEl, emoji }) => { input.value = 5; updateSliderVisuals(input, valueEl, emoji); });
                DOM.form.stepsInput.value = 0; DOM.form.phoneMinutesInput.value = 0; DOM.form.kmRunInput.value = 0; DOM.form.notesInput.value = '';
                DOM.form.saveEntryBtn.innerHTML = '<span>💾</span> Salva MindTrack'; DOM.form.formMessage.style.display = 'none';
                if (focusDate) { DOM.form.dateInput.focus(); }
            }
             function populateFormForEdit(entryId) {
                const entry = appState.entries.find(e => e.id === entryId);
                if (entry) {
                    DOM.form.editingEntryId.value = entry.id; DOM.form.dateInput.value = entry.date;
                    DOM.form.moodInput.value = entry.mood; DOM.form.sleepInput.value = entry.sleep; DOM.form.energyInput.value = entry.energy;
                    DOM.form.anxietyInput.value = entry.anxiety; DOM.form.dissociationInput.value = entry.dissociation; DOM.form.boredomInput.value = entry.boredom;
                    DOM.form.stepsInput.value = entry.steps || 0; DOM.form.phoneMinutesInput.value = entry.phoneMinutes || 0; DOM.form.kmRunInput.value = entry.kmRun || 0;
                    DOM.form.notesInput.value = entry.notes || '';
                    SLIDER_MAP.forEach(({ input, valueEl, emoji }) => updateSliderVisuals(input, valueEl, emoji));
                    DOM.form.saveEntryBtn.innerHTML = '<span>💾</span> Aggiorna MindTrack'; showView('form'); DOM.form.dateInput.focus();
                } else { console.error("Entry not found:", entryId); showUIMessage(DOM.form.formMessage, "Errore: MindTrack non trovato.", "error"); }
            }
             async function handleSaveEntry(event) {
                event.preventDefault(); const entryId = DOM.form.editingEntryId.value; const date = DOM.form.dateInput.value;
                if (!date) { showUIMessage(DOM.form.formMessage, 'Data obbligatoria.', 'error'); DOM.form.dateInput.focus(); return; }
                const existingEntryIndexOnDate = appState.entries.findIndex(e => e.date === date && e.id !== entryId);
                if (existingEntryIndexOnDate !== -1) { showUIMessage(DOM.form.formMessage, `Registrazione già esistente per ${formatDateForDisplay(date)}.`, 'error', 5000); DOM.form.dateInput.focus(); return; }
                const entryData = { id: entryId || `entry_${Date.now()}`, date: date, mood: parseInt(DOM.form.moodInput.value, 10), sleep: parseInt(DOM.form.sleepInput.value, 10), energy: parseInt(DOM.form.energyInput.value, 10), anxiety: parseInt(DOM.form.anxietyInput.value, 10), dissociation: parseInt(DOM.form.dissociationInput.value, 10), boredom: parseInt(DOM.form.boredomInput.value, 10), steps: Math.max(0, parseInt(DOM.form.stepsInput.value, 10) || 0), phoneMinutes: Math.max(0, parseInt(DOM.form.phoneMinutesInput.value, 10) || 0), kmRun: Math.max(0, parseFloat(DOM.form.kmRunInput.value) || 0), notes: DOM.form.notesInput.value.trim() };
                if (entryId) {
                    const indexToUpdate = appState.entries.findIndex(e => e.id === entryId);
                    if (indexToUpdate !== -1) { appState.entries[indexToUpdate] = entryData; showUIMessage(DOM.form.formMessage, 'Aggiornato!', 'success'); }
                    else { console.error("Update Error: ID not found", entryId); showUIMessage(DOM.form.formMessage, 'Errore aggiornamento.', 'error'); return; }
                } else { appState.entries.push(entryData); showUIMessage(DOM.form.formMessage, 'Salvato!', 'success'); }
                await saveEntries(); resetForm(false); DOM.form.formMessage.focus();
            }


            // --- Unified Diary Rendering ---
            function renderDiary() {
                console.log("=== INIZIO renderDiary ===");
                console.log("renderDiary() chiamato - Test disponibili:", appState.testResults.length);
                
                // Controlla se ci sono duplicati negli ID dei test
                const testIds = appState.testResults.map(t => t.id);
                const uniqueIds = [...new Set(testIds)];
                if (testIds.length !== uniqueIds.length) {
                    console.error("ATTENZIONE: Trovati test duplicati!");
                    console.log("Test totali:", testIds.length, "Test unici:", uniqueIds.length);
                }
                
                DOM.diary.diaryList.innerHTML = '';
                
                // Collect all diary items with type information
                const allDiaryItems = [];
                
                // Add MindTrack entries
                appState.entries.forEach(entry => {
                    allDiaryItems.push({
                        type: 'mindtrack',
                        date: new Date(entry.date),
                        data: entry
                    });
                });
                
                // Add test results
                appState.testResults.forEach(result => {
                    allDiaryItems.push({
                        type: 'test',
                        date: new Date(result.completionDate),
                        data: result
                    });
                });
                
                // Apply filter
                const filteredItems = allDiaryItems.filter(item => {
                    if (appState.diaryFilter === 'all') return true;
                    if (appState.diaryFilter === 'mindtrack') return item.type === 'mindtrack';
                    if (appState.diaryFilter === 'tests') return item.type === 'test';
                    return true;
                });
                
                // Sort by date (newest first)
                filteredItems.sort((a, b) => b.date - a.date);
                
                if (filteredItems.length === 0) {
                    DOM.diary.emptyMessage.style.display = 'block';
                    DOM.diary.diaryList.style.display = 'none';
                    return;
                }
                
                DOM.diary.emptyMessage.style.display = 'none';
                DOM.diary.diaryList.style.display = 'flex';
                
                const fragment = document.createDocumentFragment();
                
                filteredItems.forEach(item => {
                    if (item.type === 'mindtrack') {
                        // Render MindTrack entry
                        const entry = item.data;
                        const card = document.createElement('article');
                        card.className = 'entry-card fade-in';
                        card.setAttribute('aria-labelledby', `entry-date-${entry.id}`);
                        card.dataset.entryId = entry.id;
                        
                        const createGridItem = (label, value, emoji = '', unit = '', isFeeling = false, alwaysShow = false) => {
                            if (value > 0 || isFeeling || alwaysShow) {
                                return `<div class="entry-item"><strong>${emoji} ${label}:</strong> <span>${value}${unit}</span></div>`;
                            }
                            return '';
                        };
                        
                        const notesHtml = entry.notes ? `<div class="entry-notes"><strong class="entry-notes-label">Note:</strong><p>${entry.notes.replace(/\n/g, '<br>')}</p></div>` : '';
                        
                        card.innerHTML = `
                            <div class="entry-header">
                                <span class="date" id="entry-date-${entry.id}">${formatDateForDisplay(entry.date)}</span>
                                <div class="entry-actions">
                                    <button class="edit-entry-btn" data-id="${entry.id}" aria-label="Modifica ${formatDateForDisplay(entry.date)}">✏️<span class="sr-only">Modifica</span></button>
                                    <button class="delete-entry-btn" data-id="${entry.id}" aria-label="Elimina ${formatDateForDisplay(entry.date)}">🗑️<span class="sr-only">Elimina</span></button>
                                </div>
                            </div>
                            <div class="entry-grid">
                                ${createGridItem('Umore', entry.mood, MOOD_EMOJIS[entry.mood] || '😐', '/10', true)}
                                ${createGridItem('Sonno', entry.sleep, '😴', '/10', true)}
                                ${createGridItem('Energia', entry.energy, '⚡', '/10', true)}
                                ${createGridItem('Ansia', entry.anxiety, '😰', '/10', true)}
                                ${createGridItem('Dissociazione', entry.dissociation, '🫥', '/10', true)}
                                ${createGridItem('Noia', entry.boredom, '😐', '/10', true)}
                                ${createGridItem('Passi', entry.steps, '👣')}
                                ${createGridItem('Min. Telefono', entry.phoneMinutes, '📱')}
                                ${createGridItem('Km Corsi', (entry.kmRun || 0).toLocaleString('it-IT'), '🏃', '', false, true)}
                            </div>
                            ${notesHtml}`;
                        
                        fragment.appendChild(card);
                    } else if (item.type === 'test') {
                        // Render test result
                        const result = item.data;
                        
                        // Verifica che tutti i campi necessari siano definiti
                        if (!result || !result.testId || !result.testName || !result.completionDate || result.totalScore === undefined) {
                            console.error("Dati test incompleti:", result);
                            return; // Salta questo risultato di test invece di mostrare valori undefined
                        }
                        
                        const card = document.createElement('article');
                        card.className = 'test-result-card fade-in';
                        card.setAttribute('aria-labelledby', `test-result-${result.testId}-${result.completionDate}`);
                        card.dataset.resultId = result.id; // Usa l'ID univoco del test
                        
                        // Preparazione del rendering delle risposte individuali
                        let answersString = '';
                        if (Array.isArray(result.individualScores)) {
                            // Ottieni le domande dal database dei test se disponibili
                            const testData = TESTS_DATA[result.testId];
                            const questions = testData ? testData.questions : [];
                            
                            answersString = result.individualScores.map((score, index) => {
                                const questionText = questions[index] || `Domanda ${index + 1}`;
                                return `<div class="test-answer"><span class="question">${questionText}</span>: <span class="score">${score}</span></div>`;
                            }).join('');
                        }
                        
                        card.innerHTML = `
                            <div class="test-result-header">
                                <span class="test-name" id="test-result-${result.testId}-${result.completionDate}">${result.testName}</span>
                                <span class="test-date">${formatDateTimeForDisplay(result.completionDate)}</span>
                                <div class="entry-actions">
                                    <button class="edit-test-btn" data-id="${result.id}" data-test-id="${result.testId}" aria-label="Modifica test ${result.testName} del ${formatDateTimeForDisplay(result.completionDate)}">✏️<span class="sr-only">Modifica</span></button>
                                    <button class="delete-test-btn" data-id="${result.id}" aria-label="Elimina test ${result.testName} del ${formatDateTimeForDisplay(result.completionDate)}">🗑️<span class="sr-only">Elimina</span></button>
                                </div>
                            </div>
                            <div class="test-result-body">
                                <p class="total-score">Punteggio Totale: <strong>${result.totalScore}</strong></p>
                                <div class="test-result-details">
                                    <h4>Risposte:</h4>
                                    <div class="test-result-answers">
                                        ${answersString || '<p class="no-answers">Dettaglio risposte non disponibile</p>'}
                                    </div>
                                </div>
                            </div>`;
                        
                        fragment.appendChild(card);
                    }
                });
                
                DOM.diary.diaryList.appendChild(fragment);
            }
            
            async function handleDeleteEntry(entryId) {
                const entryToDelete = appState.entries.find(e => e.id === entryId);
                if (!entryToDelete) return;
                
                if (confirm(`Eliminare MindTrack del ${formatDateForDisplay(entryToDelete.date)}?`)) {
                    appState.entries = appState.entries.filter(e => e.id !== entryId);
                    await saveEntries();
                    showUIMessage(DOM.diary.actionMessage, 'Eliminato.', 'success', 3000);
                    DOM.diary.actionMessage.focus();
                    
                    const cardElement = DOM.diary.diaryList.querySelector(`.entry-card[data-entry-id="${entryId}"]`);
                    if (cardElement) { cardElement.remove(); }
                    
                    if (appState.entries.length === 0 || filteredEntriesCount() === 0) {
                        renderDiary();
                    }
                }
            }
            
            async function handleDeleteTest(testId) {
                console.log("handleDeleteTest chiamato con ID:", testId);
                
                // Cerca il test sia per ID che per completionDate per compatibilità
                let testToDelete = appState.testResults.find(t => t.id === testId);
                if (!testToDelete) {
                    testToDelete = appState.testResults.find(t => t.completionDate === testId);
                }
                
                if (!testToDelete) {
                    console.error("Test da eliminare non trovato con ID:", testId);
                    return;
                }
                
                console.log("Test da eliminare trovato:", testToDelete.testName);
                
                if (confirm(`Eliminare il test ${testToDelete.testName} del ${formatDateTimeForDisplay(testToDelete.completionDate)}?`)) {
                    console.log("Eliminando test con ID:", testId);
                    console.log("Test prima dell'eliminazione:", appState.testResults.length);
                    
                    // Debug: mostra tutti gli ID dei test per capire la struttura
                    console.log("Tutti i test con i loro ID:");
                    appState.testResults.forEach((t, i) => {
                        console.log(`Test ${i}: id = "${t.id}", testName = "${t.testName}", completionDate = "${t.completionDate}"`);
                    });
                    console.log(`Cercando di eliminare il test con ID: "${testId}"`);
                    
                    // Usa l'ID del test trovato
                    const testToDeleteId = testToDelete.id;
                    console.log(`Eliminando test con ID: ${testToDeleteId}`);
                    
                    // Filtra il test da eliminare usando l'ID univoco
                    appState.testResults = appState.testResults.filter(t => {
                        const shouldKeep = t.id !== testToDeleteId;
                        if (!shouldKeep) {
                            console.log(`Eliminando test: ${t.testName} con ID ${t.id}`);
                        }
                        return shouldKeep;
                    });
                    
                    console.log("Test dopo l'eliminazione:", appState.testResults.length);
                    
                    // Salva solo i test rimanenti al server
                    try {
                        // Salva al server usando l'endpoint specifico per i test
                        const response = await fetch(`${API_BASE}/tests`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                contenuto: JSON.stringify(appState.testResults)
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Errore server: ${response.status}`);
                        }
                        
                        const result = await response.json();
                        if (!result.ok) {
                            throw new Error(result.errore || 'Errore nel salvataggio remoto');
                        }
                        
                        console.log("Test rimanenti salvati con successo al server");
                        
                        // Salva anche in localStorage come backup
                        localStorage.setItem(TEST_RESULTS_STORAGE_KEY, JSON.stringify(appState.testResults));
                        
                        showUIMessage(DOM.diary.actionMessage, 'Test eliminato con successo.', 'success', 3000);
                        
                    } catch (error) {
                        console.error("Errore nel salvataggio dopo eliminazione:", error);
                        // Salva almeno in localStorage come fallback
                        localStorage.setItem(TEST_RESULTS_STORAGE_KEY, JSON.stringify(appState.testResults));
                        showUIMessage(DOM.diary.actionMessage, 'Test eliminato (salvato solo localmente).', 'warning', 5000);
                    }
                    
                    // Aggiorna l'interfaccia senza ricaricare i dati
                    populateWeeksData(); 
                    updateCharts();
                    
                    // Rimuovi l'elemento dall'interfaccia
                    const cardElement = DOM.diary.diaryList.querySelector(`.test-result-card[data-result-id="${testToDeleteId}"]`);
                    if (cardElement) { 
                        cardElement.remove(); 
                        console.log("Elemento rimosso dall'interfaccia");
                    }
                    
                    // Se non ci sono più test, rigenera la vista
                    if (appState.testResults.length === 0) {
                        renderDiary();
                    }
                }
            }
            
            function editTest(completionDate, testId) {
                // Trova il test da modificare
                const testToEdit = appState.testResults.find(t => t.completionDate === completionDate);
                if (!testToEdit) {
                    console.error("Test da modificare non trovato");
                    return;
                }
                
                // Ottieni i dati del tipo di test
                const testData = TESTS_DATA[testId];
                if (!testData) {
                    console.error("Dati del test non trovati:", testId);
                    return;
                }
                
                // Inizializza il test con i valori esistenti
                // Assicurati che individualScores non sia più lungo del numero di domande
                const validIndividualScores = testToEdit.individualScores.slice(0, testData.numQuestions);
                
                appState.currentTest = {
                    id: testId,
                    name: testData.name,
                    questions: testData.questions,
                    scores: [...validIndividualScores], // Usa solo i punteggi validi
                    currentIndex: 0,
                    isEditing: true, // Flag per indicare che stiamo modificando
                    editingCompletionDate: completionDate // Salva la data originale per l'aggiornamento
                };
                
                // Passa alla vista del test
                showView('takeTest');
                
                // Mostra il test
                DOM.takeTest.resultsArea.style.display = 'none'; 
                DOM.takeTest.modalScoreErrorMessage.style.display = 'none';
                
                // Visualizza la prima domanda e apri il modale
                displayCurrentQuestion();
                showTestModal();
                DOM.takeTest.modalTitle.textContent = `Modifica ${testData.name}`;
            }
            
            function filteredEntriesCount() {
                let count = 0;
                if (appState.diaryFilter === 'all' || appState.diaryFilter === 'mindtrack') {
                    count += appState.entries.length;
                }
                if (appState.diaryFilter === 'all' || appState.diaryFilter === 'tests') {
                    count += appState.testResults.length;
                }
                return count;
            }

            // --- Chart Logic ---
            function destroyCharts() {
                Object.keys(appState.chartInstances).forEach(k => {
                    if(appState.chartInstances[k]) {
                        appState.chartInstances[k].destroy();
                        appState.chartInstances[k] = null;
                    }
                });
            }
            function initializeOrUpdateChart(c,t,l,d){const x=c.getContext('2d');if(!x){console.error("Ctx fail:",c.id);return}
                // Opzioni di base uniformi per tutti i grafici
                let o={
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            ticks: {
                                autoSkip: true, 
                                maxRotation: 0, 
                                minRotation: 0,
                                font: {size: 12}
                            },
                            grid: {
                                color: '#f3f4f6',
                                display: d.type === 'bar' ? false : true
                            }
                        },
                        y: {
                            beginAtZero: d.beginAtZero !== undefined ? d.beginAtZero : true,
                            ticks: {font: {size: 12}},
                            grid: {color: '#e5e7eb'}
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true, 
                                pointStyle: 'circle',
                                boxWidth: 8,
                                padding: 10,
                                font: {size: 14}
                            },
                            box: {padding: 8}
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            bodyFont: {size: 14},
                            titleFont: {size: 15},
                            padding: 10
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    animation: {
                        duration: 500,
                        easing: 'easeInOutQuad'
                    },
                    // Configura elementi visivi uniformemente per tutti i tipi di grafici
                    elements: {
                        line: { 
                            borderWidth: 3,
                            tension: 0.1
                        },
                        point: {
                            radius: 6,
                            hoverRadius: 8,
                            borderWidth: 1.5
                        },
                        bar: {
                            borderWidth: 2,
                            borderRadius: 6
                        }
                    }
                };if(d.type==='bar'){o.maxBarThickness=60;o.scales.y.grid={color:'#e5e7eb',drawBorder:!1};o.scales.x.grid={display:!1};const v=d.datasets[0]?.data||[];const m=v.length>0?Math.max(...v.map(v=>v||0)):0;if(t==='steps')o.scales.y.suggestedMax=Math.max(5e3,Math.ceil(m*1.1/1e3)*1e3);else if(t==='phone')o.scales.y.suggestedMax=Math.max(60,Math.ceil(m*1.1/10)*10);else if(t==='kmRun')o.scales.y.suggestedMax=Math.max(5,Math.ceil(m*1.15));else o.scales.y.suggestedMax=Math.ceil(m*1.1)}else{o.scales.y.suggestedMax=10;o.scales.y.suggestedMin=0;o.scales.y.grid={color:'#e5e7eb'};o.scales.x.grid={color:'#f3f4f6'}}if(appState.chartInstances[t]){appState.chartInstances[t].data.labels=l;appState.chartInstances[t].data.datasets=d.datasets;appState.chartInstances[t].options=o;appState.chartInstances[t].update()}else{appState.chartInstances[t]=new Chart(x,{type:d.type||'line',data:{labels:l,datasets:d.datasets},options:o})}}
            
            function updateMindtrackChart() {
                let entries = [];
                if (appState.chartViewMode === 'weekly') {
                    if (appState.weeksData.length > 0 && appState.currentWeekOffset >= 0 && appState.currentWeekOffset < appState.weeksData.length) {
                        entries = appState.weeksData[appState.currentWeekOffset].entries;
                    }
                } else {
                    entries = appState.entries;
                }
                
                const hasData = entries.length > 0;
                DOM.chart.chartEmptyMessage.style.display = hasData ? 'none' : 'block';
                // Rimuovi la classe che sposta il messaggio più in basso quando mostri i messaggi di MindTrack
                if (!hasData) {
                    DOM.chart.chartEmptyMessage.classList.remove('test-empty-message-lower');
                    DOM.chart.chartEmptyMessage.innerHTML = '<strong>Nessun dato da visualizzare.</strong><br>Aggiungi qualche MindTrack usando la scheda \'Aggiungi\' per vedere i grafici.';
                }
                DOM.chart.chartContainers.forEach(c => c.style.opacity = hasData ? 1 : 0.3);
                
                if (!hasData) {
                    if (appState.chartInstances.mindtrack) {
                        appState.chartInstances.mindtrack.destroy();
                        appState.chartInstances.mindtrack = null;
                    }
                    return;
                }
                
                const labels = entries.map(e => formatDateForDisplay(e.date));
                const canvas = document.getElementById('mindtrack-chart');
                
                switch (appState.activeMindtrackChart) {
                    case 'mood':
                        initializeOrUpdateChart(canvas, 'mindtrack', labels, {
                            type: 'line',
                            datasets: [
                                {label: 'Umore', data: entries.map(e => e.mood), borderColor: '#3b82f6', backgroundColor: '#3b82f6', fill: false},
                                {label: 'Sonno', data: entries.map(e => e.sleep), borderColor: '#10b981', backgroundColor: '#10b981', fill: false},
                                {label: 'Energia', data: entries.map(e => e.energy), borderColor: '#f59e0b', backgroundColor: '#f59e0b', fill: false},
                                {label: 'Ansia', data: entries.map(e => e.anxiety), borderColor: '#ef4444', backgroundColor: '#ef4444', fill: false},
                                {label: 'Dissociazione', data: entries.map(e => e.dissociation), borderColor: '#8b5cf6', backgroundColor: '#8b5cf6', fill: false},
                                {label: 'Noia', data: entries.map(e => e.boredom), borderColor: '#6b7280', backgroundColor: '#6b7280', fill: false},
                            ]
                        });
                        break;
                    case 'steps':
                        initializeOrUpdateChart(canvas, 'mindtrack', labels, {
                            type: 'bar',
                            datasets: [{
                                label: 'Passi Giornalieri', 
                                data: entries.map(e => e.steps), 
                                backgroundColor: '#14b8a6',
                                borderColor: '#14b8a6', // Stesso colore di sfondo per rimuovere il bordo nella legenda
                                pointStyle: 'circle' // Forza lo stile del punto nella legenda
                            }]
                        });
                        break;
                    case 'phone':
                        initializeOrUpdateChart(canvas, 'mindtrack', labels, {
                            type: 'bar',
                            datasets: [{
                                label: 'Minuti Telefono', 
                                data: entries.map(e => e.phoneMinutes), 
                                backgroundColor: '#6366f1',
                                borderColor: '#6366f1', // Stesso colore di sfondo per rimuovere il bordo nella legenda
                                pointStyle: 'circle' // Forza lo stile del punto nella legenda
                            }]
                        });
                        break;
                    case 'kmRun':
                        initializeOrUpdateChart(canvas, 'mindtrack', labels, {
                            type: 'bar',
                            datasets: [{
                                label: 'Km Corsi', 
                                data: entries.map(e => e.kmRun), 
                                backgroundColor: '#059669', 
                                borderColor: '#059669', // Stesso colore di sfondo per rimuovere il bordo nella legenda
                                pointStyle: 'circle' // Forza lo stile del punto nella legenda
                            }]
                        });
                        break;
                }
            }
            
            function updateTestsChart() {
                const canvas = document.getElementById('tests-chart');
                const chartEmptyMessage = document.getElementById('chart-empty-message');
                if (!canvas) return;
                
                let filteredResults = appState.testResults;
                
                // Filtra per test selezionato
                if (appState.selectedTest !== 'all') {
                    filteredResults = filteredResults.filter(r => r.testId === appState.selectedTest);
                }
                
                // Filtra per settimana selezionata
                if (appState.chartViewMode === 'weekly' && appState.weeksData.length > 0) {
                    const currentWeek = appState.weeksData[appState.currentWeekOffset];
                    if (currentWeek) {
                        const startDate = new Date(currentWeek.startDate);
                        const endDate = new Date(currentWeek.endDate);
                        endDate.setHours(23, 59, 59, 999); // Fine della giornata
                        
                        filteredResults = filteredResults.filter(r => {
                            const resultDate = new Date(r.completionDate);
                            return resultDate >= startDate && resultDate <= endDate;
                        });
                    }
                }
                
                // Ordina per data
                filteredResults.sort((a, b) => new Date(a.completionDate) - new Date(b.completionDate));
                
                // Mostra messaggio "nessun dato" se non ci sono risultati
                if (filteredResults.length === 0) {
                    if (appState.chartInstances.tests) {
                        appState.chartInstances.tests.destroy();
                        appState.chartInstances.tests = null;
                    }
                    
                    if (chartEmptyMessage) {
                        // Se siamo nella vista "Tabella domande", non mostrare il messaggio nel grafico
                        // perché verrà mostrato nella tabella
                        if (appState.activeTestView === 'table') {
                            chartEmptyMessage.style.display = 'none';
                        } else {
                            chartEmptyMessage.style.display = 'block';
                            chartEmptyMessage.classList.add('test-empty-message-lower');
                            chartEmptyMessage.innerHTML = '<strong>Non ci sono dati dei test da visualizzare.</strong><br>Vai nella sezione "Fai un Test" per completare un test e visualizzare i grafici qui.';
                        }
                    }
                    
                    return;
                } else if (chartEmptyMessage) {
                    chartEmptyMessage.style.display = 'none';
                }
                
                if (appState.activeTestView === 'totals') {
                    let labels = [];
                    const datasets = [];
                    
                    if (appState.selectedTest === 'all') {
                        // Per tutti i test, raggruppiamo per data per evitare date duplicate
                        // Prima otteniamo un array di date uniche
                        const uniqueDates = [...new Set(filteredResults.map(r => formatDateTimeForDisplay(r.completionDate)))];
                        labels = uniqueDates.sort((a, b) => {
                            // Converte le date dal formato italiano (dd/mm/yyyy) per il confronto
                            const parts1 = a.split('/').reverse();
                            const parts2 = b.split('/').reverse();
                            return new Date(parts1.join('-')) - new Date(parts2.join('-'));
                        });
                        
                        // Ottieni tutti i tipi di test presenti nei risultati
                        let testTypes = [...new Set(filteredResults.map(r => r.testId))];
                        
                        // Riordina i tipi di test per mettere IDS-SR30 per ultimo
                        if (testTypes.includes('idssr30')) {
                            // Rimuovi IDS-SR30 dalla lista attuale
                            testTypes = testTypes.filter(id => id !== 'idssr30');
                            // Aggiungi IDS-SR30 alla fine
                            testTypes.push('idssr30');
                        }
                        
                        const colors = {
                            phq9: '#ef4444',
                            bdiii: '#f97316',
                            cesd: '#eab308',
                            hads: '#84cc16',
                            idssr30: '#06b6d4'
                        };
                        
                        testTypes.forEach(testId => {
                            const testData = filteredResults.filter(r => r.testId === testId);
                            // Prepara i dati allineati alle date
                            const data = labels.map(date => {
                                const result = testData.find(r => formatDateTimeForDisplay(r.completionDate) === date);
                                return result ? result.totalScore : null;
                            });
                            
                            datasets.push({
                                label: TESTS_DATA[testId]?.name || testId,
                                data: data,
                                borderColor: colors[testId] || '#6b7280',
                                backgroundColor: colors[testId] || '#6b7280',
                                fill: false,
                                tension: 0.2, // Aggiunge una leggera curvatura alla linea
                                pointBackgroundColor: colors[testId] || '#6b7280',
                                pointRadius: 4,
                                pointHoverRadius: 6
                            });
                        });
                    } else {
                        // Per un singolo test, usa le labels direttamente dai risultati filtrati
                        labels = filteredResults.map(r => formatDateTimeForDisplay(r.completionDate));
                        
                        // Usa lo stesso colore del test che viene usato nella vista "tutti i test"
                        const colors = {
                            phq9: '#ef4444',
                            bdiii: '#f97316',
                            cesd: '#eab308',
                            hads: '#84cc16',
                            idssr30: '#06b6d4'
                        };
                        
                        const testColor = colors[appState.selectedTest] || '#4f46e5'; // Colore di fallback
                        
                        datasets.push({
                            label: `Punteggio ${TESTS_DATA[appState.selectedTest]?.name || appState.selectedTest}`,
                            data: filteredResults.map(r => r.totalScore),
                            borderColor: testColor,
                            backgroundColor: testColor,
                            fill: false,
                            tension: 0.2, // Aggiunge una leggera curvatura alla linea
                            pointBackgroundColor: testColor,
                            pointRadius: 4,
                            pointHoverRadius: 6
                        });
                    }
                    
                    initializeOrUpdateChart(canvas, 'tests', labels, {
                        type: 'line',
                        datasets: datasets
                    });
                } else {
                    // Questions view
                    if (appState.selectedTest === 'all') {
                        if (appState.chartInstances.tests) {
                            appState.chartInstances.tests.destroy();
                            appState.chartInstances.tests = null;
                        }
                        
                        // Usa un approccio più sicuro per mostrare il messaggio senza rimuovere il canvas
                        const container = canvas.parentElement;
                        
                        // Rimuovi messaggi precedenti se presenti
                        const existingMsg = container.querySelector('.question-view-message');
                        if (existingMsg) existingMsg.remove();
                        
                        // Aggiungi il nuovo messaggio
                        const messageEl = document.createElement('p');
                        messageEl.className = 'question-view-message';
                        messageEl.style.cssText = 'text-align: center; margin-top: 2rem; color: var(--text-muted);';
                        messageEl.textContent = 'Seleziona un test specifico per vedere i dettagli.';
                        
                        // Nascondi il canvas
                        canvas.style.display = 'none';
                        
                        // Aggiungi il messaggio dopo il canvas
                        container.appendChild(messageEl);
                        return;
                    }
                    
                    // Nascondi sempre il canvas nella vista tabella
                    canvas.style.display = 'none';
                    
                    // Rimuovi eventuali messaggi
                    const container = canvas.parentElement;
                    const existingMsg = container.querySelector('.question-view-message');
                    if (existingMsg) existingMsg.remove();
                    
                    // Distruggi l'istanza del grafico se esiste
                    if (appState.chartInstances.tests) {
                        appState.chartInstances.tests.destroy();
                        appState.chartInstances.tests = null;
                    }
                }
            }
            
            function updateCharts() {
                if (appState.activeView === 'chart') {
                    if (appState.activeChartView === 'mindtrack') {
                        updateMindtrackChart();
                    } else if (appState.activeChartView === 'tests') {
                        updateTestsChart();
                    }
                    updateWeekNavigationUI();
                }
            }
            
            function switchChartView(view) {
                if (!['mindtrack', 'tests'].includes(view)) {
                    view = 'mindtrack';
                }
                appState.activeChartView = view;
                DOM.chart.chartTabs.forEach(b => {
                    const isActive = b.id === `${view}-chart-tab-btn`;
                    b.classList.toggle('active', isActive);
                    b.setAttribute('aria-selected', isActive);
                    b.setAttribute('tabindex', isActive ? '0' : '-1');
                });
                DOM.chart.chartContainers.forEach(c => {
                    const isActive = c.id === `${view}-chart-container`;
                    c.style.display = isActive ? 'block' : 'none';
                    c.setAttribute('aria-hidden', !isActive);
                });
                
                // Nasconde il messaggio "nessun dato" quando si cambia vista
                const chartEmptyMessage = document.getElementById('chart-empty-message');
                if (chartEmptyMessage) {
                    chartEmptyMessage.style.display = 'none';
                }
                
                // Mostra/nascondi subtabs e selettore
                const mindtrackSubtabs = document.getElementById('mindtrack-subtabs');
                const testsSubtabs = document.getElementById('tests-subtabs');
                const testSelector = document.getElementById('test-selector');
                const testsChart = document.getElementById('tests-chart');
                const testDetailsContainer = document.getElementById('test-details-container');
                
                if (view === 'mindtrack') {
                    mindtrackSubtabs.style.display = 'flex';
                    testsSubtabs.style.display = 'none';
                    testSelector.style.display = 'none';
                    
                    // Riabilita sempre i pulsanti Tutto e Sett. corrente quando si passa a MindTrack
                    const viewAllDataBtn = document.getElementById('view-all-data');
                    const viewCurrentWeekDataBtn = document.getElementById('view-current-week-data');
                    
                    // Rimuove la classe disabled
                    viewAllDataBtn.classList.remove('disabled');
                    viewCurrentWeekDataBtn.classList.remove('disabled');
                    
                    // Ripristina correttamente la classe active in base alla modalità corrente
                    const isAllMode = appState.chartViewMode === 'all';
                    viewAllDataBtn.classList.toggle('active', isAllMode);
                    viewCurrentWeekDataBtn.classList.toggle('active', !isAllMode);
                    
                    updateCharts();
                } else {
                    mindtrackSubtabs.style.display = 'none';
                    testsSubtabs.style.display = 'flex';
                    // Mostra il selettore dei test solo nella vista "Tabella domande"
                    testSelector.style.display = appState.activeTestView === 'table' ? 'block' : 'none';
                    
                    // Gestione pulsanti "Tutto" e "Sett. corrente" solo se siamo in tabella domande
                    if (appState.activeTestView === 'table') {
                        const viewAllDataBtn = document.getElementById('view-all-data');
                        const viewCurrentWeekDataBtn = document.getElementById('view-current-week-data');
                        // Disabilita i pulsanti nella vista tabella domande
                        viewAllDataBtn.classList.add('disabled');
                        viewCurrentWeekDataBtn.classList.add('disabled');
                    }
                    
                    // Se siamo nella vista test, verificare se ci sono dati
                    if (appState.testResults.length === 0) {
                        const chartEmptyMessage = document.getElementById('chart-empty-message');
                        if (chartEmptyMessage) {
                            chartEmptyMessage.innerHTML = '<strong>Non ci sono dati dei test da visualizzare.</strong><br>Vai nella sezione "Fai un Test" per completare un test e visualizzare i grafici qui.';
                            chartEmptyMessage.classList.add('test-empty-message-lower');
                            chartEmptyMessage.style.display = 'block';
                        }
                    } else {
                        // Gestisci la visualizzazione in base al sub-tab attivo
                        if (appState.activeTestView === 'table') {
                            testsChart.style.display = 'none';
                            testDetailsContainer.style.display = 'block';
                            generateTestDetailsTable();
                        } else {
                            testsChart.style.display = 'block';
                            testDetailsContainer.style.display = 'none';
                            updateCharts();
                        }
                    }
                }
            }
            function handleChartTabKeydown(e) {
                const tabs = Array.from(DOM.chart.chartTabs);
                const currentIndex = tabs.findIndex(tab => tab === document.activeElement);
                
                if(currentIndex === -1 && !['ArrowRight','ArrowLeft','Home','End'].includes(e.key))
                    return;
                    
                let newIndex;
                switch(e.key) {
                    case 'ArrowRight':
                        newIndex = (currentIndex + 1) % tabs.length;
                        break;
                    case 'ArrowLeft':
                        newIndex = (currentIndex - 1 + tabs.length) % tabs.length;
                        break;
                    case 'Home':
                        newIndex = 0;
                        break;
                    case 'End':
                        newIndex = tabs.length - 1;
                        break;
                    default:
                        return;
                }
                
                e.preventDefault();
                tabs[newIndex].focus();
            }
            function handleChartTabClick(e) {
                const tab = e.target.closest('.chart-tab');
                if(tab) {
                    const view = tab.id.replace('-chart-tab-btn', '');
                    switchChartView(view);
                }
            }
            function populateWeeksData() {
                // Reimpostazione dei dati per le settimane
                appState.weeksData = [];
                
                // Se non ci sono voci, termina subito
                if (appState.entries.length === 0) return;
                
                // Ordinamento delle voci per data
                const sortedEntries = [...appState.entries].sort((a, b) => new Date(a.date) - new Date(b.date));
                
                let currentWeekStart = null;
                let weekEntries = [];
                
                // Raggruppa le voci per settimana
                sortedEntries.forEach(entry => {
                    const entryDate = new Date(entry.date);
                    if (isNaN(entryDate.getTime())) return;
                    
                    const weekStart = getStartOfWeek(entryDate);
                    
                    if (!currentWeekStart || weekStart.getTime() !== currentWeekStart.getTime()) {
                        // Salva la settimana precedente se esiste
                        if (currentWeekStart && weekEntries.length > 0) {
                            const weekEnd = new Date(currentWeekStart);
                            weekEnd.setDate(currentWeekStart.getDate() + 6);
                            
                            appState.weeksData.push({
                                startDate: formatDateISO(currentWeekStart),
                                endDate: formatDateISO(weekEnd),
                                entries: weekEntries
                            });
                        }
                        
                        // Inizia una nuova settimana
                        currentWeekStart = weekStart;
                        weekEntries = [entry];
                    } else {
                        // Aggiungi alla settimana corrente
                        weekEntries.push(entry);
                    }
                });
                
                // Salva l'ultima settimana se ci sono voci
                if (currentWeekStart && weekEntries.length > 0) {
                    const weekEnd = new Date(currentWeekStart);
                    weekEnd.setDate(currentWeekStart.getDate() + 6);
                    
                    appState.weeksData.push({
                        startDate: formatDateISO(currentWeekStart),
                        endDate: formatDateISO(weekEnd),
                        entries: weekEntries
                    });
                }
                
                // Assicurati che l'offset corrente sia valido
                if (appState.currentWeekOffset >= appState.weeksData.length) {
                    appState.currentWeekOffset = Math.max(0, appState.weeksData.length - 1);
                }
            }
            function updateWeekNavigationUI(){
                const hasEntries = appState.weeksData.length > 0;
                
                if (appState.chartViewMode === 'all') {
                    // Modalità "Tutto"
                    DOM.chart.weekLabel.textContent = 'Tutte le settimane';
                    DOM.chart.prevWeekBtn.disabled = true;
                    DOM.chart.nextWeekBtn.disabled = true;
                } else if (appState.chartViewMode === 'weekly' && !hasEntries) {
                    // Modalità "Settimana corrente" ma nessun dato
                    // Forziamo la data corrente al giorno effettivo
                    const now = new Date();
                    // Aggiorniamo la data per assicurarci che sia il 14/05 e non il 13/05
                    now.setHours(12, 0, 0, 0); // Impostiamo l'ora a mezzogiorno per evitare problemi di timezone
                    const currentDate = now;
                    
                    // Calcoliamo inizio e fine settimana
                    const startOfWeek = getStartOfWeek(currentDate);
                    const endOfWeek = new Date(startOfWeek);
                    endOfWeek.setDate(startOfWeek.getDate() + 6);
                    
                    // Formatiamo per la visualizzazione
                    DOM.chart.weekLabel.textContent = `${formatDateForDisplay(formatDateISO(startOfWeek))} - ${formatDateForDisplay(formatDateISO(endOfWeek))}`;
                    DOM.chart.prevWeekBtn.disabled = true;
                    DOM.chart.nextWeekBtn.disabled = true;
                } else {
                    // Modalità "Settimana corrente" con dati
                    if (appState.currentWeekOffset < 0 || appState.currentWeekOffset >= appState.weeksData.length) {
                        const today = new Date();
                        let weekIndex = appState.weeksData.findIndex(week => {
                            const startDate = new Date(week.startDate);
                            const endDate = new Date(week.endDate);
                            endDate.setHours(23, 59, 59, 999);
                            return today >= startDate && today <= endDate;
                        });
                        
                        if (weekIndex === -1) {
                            weekIndex = appState.weeksData.length - 1;
                        }
                        
                        appState.currentWeekOffset = Math.max(0, weekIndex);
                    }
                    
                    const currentWeek = appState.weeksData[appState.currentWeekOffset];
                    
                    if (currentWeek) {
                        DOM.chart.weekLabel.textContent = `${formatDateForDisplay(currentWeek.startDate)} - ${formatDateForDisplay(currentWeek.endDate)}`;
                    } else {
                        DOM.chart.weekLabel.textContent = 'Settimana?';
                    }
                    
                    DOM.chart.prevWeekBtn.disabled = appState.currentWeekOffset <= 0;
                    DOM.chart.nextWeekBtn.disabled = appState.currentWeekOffset >= appState.weeksData.length - 1;
                }
            }
            function changeWeek(d){if(appState.chartViewMode!=='weekly'||appState.weeksData.length===0)return;const n=appState.currentWeekOffset+d;appState.currentWeekOffset=Math.max(0,Math.min(n,appState.weeksData.length-1));updateCharts()}
            function setChartViewMode(m){
                if(m!=='all'&&m!=='weekly')return;
                
                appState.chartViewMode=m;
                
                // Aggiorna correttamente le classi active sui pulsanti
                const viewAllDataBtn = document.getElementById('view-all-data');
                const viewCurrentWeekDataBtn = document.getElementById('view-current-week-data');
                
                viewAllDataBtn.classList.toggle('active', m === 'all');
                viewCurrentWeekDataBtn.classList.toggle('active', m === 'weekly');
                
                if(m==='weekly'&&appState.weeksData.length>0){
                    const t=formatDateISO(new Date());
                    let i=appState.weeksData.findIndex(w=>t>=w.startDate&&t<=w.endDate);
                    if(i===-1){i=appState.weeksData.length-1}
                    appState.currentWeekOffset=i>=0?i:0
                }else{
                    appState.currentWeekOffset=0
                }
                
                updateCharts()
            }

            // --- Data Import/Export ---
             function handleExportData() {
                // Verifica se ci sono dati da esportare
                if (appState.entries.length === 0 && appState.testResults.length === 0) { showUIMessage(DOM.data.importMessage, 'Nessun dato da esportare.', 'error'); return; }
                
                setButtonLoadingState(DOM.data.exportBtn, true);
                setTimeout(() => {
                    try {
                        // Prepara i dati di esportazione in formato CSV
                        
                        // Prepara un unico file CSV con tutti i dati
                        // Aggiungiamo un campo "type" per distinguere le voci e includiamo tutti i campi possibili
                        const headers = ['type', 'id', 'date', 'testId', 'testName', 'completionDate', 'totalScore', 'individualScores', 
                                        'mood', 'sleep', 'energy', 'anxiety', 'dissociation', 'boredom', 
                                        'steps', 'phoneMinutes', 'kmRun', 'notes'];
                        
                        let csvContent = headers.join(',') + '\n';
                        
                        // Aggiungi voci MindTrack
                        appState.entries.forEach(entry => {
                            const row = [];
                            // Aggiungi il tipo
                            row.push('mindtrack');
                            
                            // Riempie ogni colonna
                            for (let i = 1; i < headers.length; i++) {
                                const header = headers[i];
                                let value = entry[header] !== undefined ? entry[header] : '';
                                
                                // Formatta valori speciali
                                if (value === null) value = '';
                                else if (header === 'notes' && value) {
                                    value = `"${String(value).replace(/"/g, '""')}"`;
                                } else if (typeof value === 'string' && value.includes(',')) {
                                    value = `"${value.replace(/"/g, '""')}"`;
                                } else {
                                    value = String(value);
                                }
                                
                                row.push(value);
                            }
                            
                            csvContent += row.join(',') + '\n';
                        });
                        
                        // Aggiungi voci Test
                        appState.testResults.forEach(test => {
                            const row = [];
                            // Aggiungi il tipo
                            row.push('test');
                            
                            // Riempie ogni colonna
                            for (let i = 1; i < headers.length; i++) {
                                const header = headers[i];
                                let value = test[header] !== undefined ? test[header] : '';
                                
                                // Formatta valori speciali
                                if (value === null) value = '';
                                else if (header === 'individualScores' && value) {
                                    value = `"${JSON.stringify(value).replace(/"/g, '""')}"`;
                                } else if (typeof value === 'string' && value.includes(',')) {
                                    value = `"${value.replace(/"/g, '""')}"`;
                                } else {
                                    value = String(value);
                                }
                                
                                row.push(value);
                            }
                            
                            csvContent += row.join(',') + '\n';
                        });
                        
                        // Crea il blob e avvia il download
                        const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' });
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = `mindtrack_export_${formatDateISO(new Date())}.csv`;
                        link.style.visibility = 'hidden';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                        
                        showUIMessage(DOM.data.importMessage, 'Tutti i dati esportati con successo!', 'success');
                    } catch (error) { console.error("Export Error:", error); showUIMessage(DOM.data.importMessage, `Errore esportazione: ${error.message}`, 'error'); }
                    finally { setButtonLoadingState(DOM.data.exportBtn, false); }
                }, 50);
            }
             async function handleImportData(event) {
                const file = event.target.files[0]; if (!file) return;
                setButtonLoadingState(DOM.data.importBtnTrigger, true); showUIMessage(DOM.data.importMessage, 'Importazione...', 'success', 0);
                const reader = new FileReader();
                reader.onload = async function(e) {
                    // Procedi con l'importazione CSV
                    const csv = e.target.result;
                    try {
                        const lines = csv.split(/\r\n|\n/); if (lines.length < 2) throw new Error('CSV vuoto.');
                        const headerLine = lines[0].startsWith('\uFEFF') ? lines[0].substring(1) : lines[0]; 
                        const headers = headerLine.split(',').map(h => h.trim().toLowerCase());
                        
                        // Debug: mostra le intestazioni trovate
                        console.log('Headers trovati nel CSV:', headers);
                        
                        // Verifica se c'è un campo 'type', che indica il nuovo formato di esportazione combinato
                        const hasTypeField = headers.includes('type');
                        
                        // Se è il nuovo formato combinato
                        if (hasTypeField) {
                            const typeIdx = headers.indexOf('type');
                            const idIdx = headers.indexOf('id');
                            const dateIdx = headers.indexOf('date');
                            const testIdIdx = headers.indexOf('testid');
                            const testNameIdx = headers.indexOf('testname');
                            const completionDateIdx = headers.indexOf('completiondate');
                            const totalScoreIdx = headers.indexOf('totalscore');
                            const individualScoresIdx = headers.indexOf('individualscores');
                            
                            let mindtrackAdded = 0;
                            let testAdded = 0;
                            let mindtrackDup = 0;
                            let testDup = 0;
                            let skip = 0;
                            const errors = [];
                            
                            // Insieme di date esistenti per verificare duplicati
                            const currentEntryDates = new Set(appState.entries.map(e => e.date));
                            // Per i test, usiamo combinazione di data e id test per evitare duplicati
                            const currentTestKeys = new Set(appState.testResults.map(t => `${t.completionDate}_${t.testId}`));
                            
                            for (let i = 1; i < lines.length; i++) {
                                if (!lines[i].trim()) continue; // Skip empty lines
                                
                                // Elabora e dividi la riga CSV gestendo le virgolette
                                let values = [];
                                let currentValue = '';
                                let inQuotes = false;
                                
                                for (let j = 0; j < lines[i].length; j++) {
                                    const char = lines[i][j];
                                    
                                    if (char === '"' && !inQuotes) {
                                        inQuotes = true;
                                    } else if (char === '"' && inQuotes && j < lines[i].length - 1 && lines[i][j + 1] === '"') {
                                        // Double quote escape
                                        currentValue += '"';
                                        j++; // Skip the next quote
                                    } else if (char === '"' && inQuotes) {
                                        inQuotes = false;
                                    } else if (char === ',' && !inQuotes) {
                                        values.push(currentValue);
                                        currentValue = '';
                                    } else {
                                        currentValue += char;
                                    }
                                }
                                
                                // Aggiungi l'ultimo valore
                                values.push(currentValue);
                                
                                if (values.length !== headers.length) {
                                    errors.push(`Riga ${i}: Numero di valori non corrisponde (${values.length} vs ${headers.length}).`);
                                    skip++;
                                    continue;
                                }
                                
                                const type = typeIdx >= 0 ? values[typeIdx].toLowerCase() : '';
                                
                                // Elabora in base al tipo
                                if (type === 'mindtrack') {
                                    // Gestione dati MindTrack
                                    if (idIdx < 0 || dateIdx < 0) {
                                        errors.push(`Riga ${i}: Mancano campi obbligatori ID o date per MindTrack.`);
                                        skip++;
                                        continue;
                                    }
                                    
                                    const id = values[idIdx];
                                    const date = values[dateIdx];
                                    
                                    if (!id || !date) {
                                        errors.push(`Riga ${i}: ID o data mancanti per MindTrack.`);
                                        skip++;
                                        continue;
                                    }
                                    
                                    // Controlla se è un duplicato
                                    if (currentEntryDates.has(date)) {
                                        mindtrackDup++;
                                        continue;
                                    }
                                    
                                    // Crea l'oggetto entry
                                    const newEntry = { id, date };
                                    headers.forEach((header, index) => {
                                        if (header === 'id' || header === 'date' || header === 'type') return;
                                        
                                        if (values[index]) {
                                            // Converti i numeri in numeri
                                            if (['mood', 'sleep', 'energy', 'anxiety', 'dissociation', 'boredom', 'steps'].includes(header)) {
                                                newEntry[header] = parseInt(values[index], 10) || 0;
                                            } else if (header === 'phoneminutes') {
                                                // Correggi il nome del campo per minuti telefono
                                                newEntry['phoneMinutes'] = parseInt(values[index], 10) || 0;
                                            } else if (header === 'kmrun') {
                                                // Correggi il nome del campo per km corsi
                                                newEntry['kmRun'] = parseFloat(values[index]) || 0;
                                            } else {
                                                newEntry[header] = values[index];
                                            }
                                        }
                                    });
                                    
                                    appState.entries.push(newEntry);
                                    currentEntryDates.add(date);
                                    mindtrackAdded++;
                                    
                                } else if (type === 'test') {
                                    // Gestione dati Test
                                    if (testIdIdx < 0 || completionDateIdx < 0 || testNameIdx < 0 || totalScoreIdx < 0) {
                                        errors.push(`Riga ${i}: Mancano campi obbligatori per Test.`);
                                        skip++;
                                        continue;
                                    }
                                    
                                    const testId = values[testIdIdx];
                                    const completionDate = values[completionDateIdx];
                                    
                                    if (!testId || !completionDate) {
                                        errors.push(`Riga ${i}: TestID o data completamento mancanti.`);
                                        skip++;
                                        continue;
                                    }
                                    
                                    // Controlla se è un duplicato usando la combinazione di data e ID test
                                    const testKey = `${completionDate}_${testId}`;
                                    console.log(`Controllo duplicato: ${testKey}, esiste già: ${currentTestKeys.has(testKey)}`);
                                    if (currentTestKeys.has(testKey)) {
                                        testDup++;
                                        continue;
                                    }
                                    
                                    // Elabora individualScores
                                    let individualScores = [];
                                    if (individualScoresIdx >= 0 && values[individualScoresIdx]) {
                                        try {
                                            individualScores = JSON.parse(values[individualScoresIdx]);
                                        } catch (error) {
                                            errors.push(`Riga ${i}: Formato individualScores non valido.`);
                                            skip++;
                                            continue;
                                        }
                                    }
                                    
                                    // Crea l'oggetto test result con ID univoco garantito
                                    const timestamp = Date.now();
                                    const randomId = Math.floor(Math.random() * 10000);
                                    const newTest = {
                                        id: `imported_${testId}_${timestamp}_${randomId}`,
                                        testId,
                                        testName: values[testNameIdx],
                                        completionDate,
                                        totalScore: parseInt(values[totalScoreIdx], 10) || 0,
                                        individualScores,
                                        synced: false
                                    };
                                    
                                    appState.testResults.push(newTest);
                                    currentTestKeys.add(testKey);
                                    testAdded++;
                                    console.log('Test importato:', newTest);
                                } else {
                                    errors.push(`Riga ${i}: Tipo non riconosciuto "${type}".`);
                                    skip++;
                                }
                            }
                            
                            // Salva i dati importati
                            if (mindtrackAdded > 0) {
                                await saveEntries();
                            }
                            
                            if (testAdded > 0) {
                                // Mostra tutti i test importati
                                console.log(`Importati ${testAdded} test risultati:`, appState.testResults.slice(-testAdded));
                                await saveTestResults();
                            }
                            
                            // Aggiorna sempre l'interfaccia dopo l'importazione
                            populateWeeksData();
                            setChartViewMode('weekly');
                            updateCharts();
                            renderDiary();
                            
                            // Se ci sono test, aggiorna anche la lista dei test
                            if (appState.testResults.length > 0) {
                                renderTestList();
                            }
                            
                            // Mostra messaggio di successo/errore
                            let msg = '';
                            if (mindtrackAdded > 0 || testAdded > 0) {
                                msg = `Importazione completata: `;
                                if (mindtrackAdded > 0) {
                                    msg += `${mindtrackAdded} dati MindTrack aggiunti`;
                                    if (mindtrackDup > 0) msg += ` (${mindtrackDup} duplicati ignorati)`;
                                    if (testAdded > 0) msg += `, `;
                                }
                                if (testAdded > 0) {
                                    msg += `${testAdded} risultati Test aggiunti`;
                                    if (testDup > 0) msg += ` (${testDup} duplicati ignorati)`;
                                }
                                showUIMessage(DOM.data.importMessage, msg, 'success', 10000);
                            } else {
                                msg = 'Nessun nuovo dato importato.';
                                if (skip > 0) msg += ` ${skip} righe saltate.`;
                                if (mindtrackDup > 0) msg += ` ${mindtrackDup} dati MindTrack duplicati.`;
                                if (testDup > 0) msg += ` ${testDup} risultati Test duplicati.`;
                                if (errors.length > 0) {
                                    msg += `<br>Errori (max 5):<br><small>${errors.slice(0, 5).join('<br>')}</small>`;
                                }
                                showUIMessage(DOM.data.importMessage, msg, 'error', 10000);
                            }
                            
                            return; // Termina l'importazione del formato combinato
                        }
                        
                        // Per retrocompatibilità, supporta ancora i vecchi formati CSV
                        // Determine if this is a test results file or a regular entries file
                        const isTestFile = headers.includes('testname') || headers.includes('test_name') || headers.includes('test');
                        
                        if (isTestFile) {
                            // Handle test results import
                            const requiredTestHeaders = ['completiondate', 'testname', 'totalscore']; 
                            const allExpectedTestHeaders = ['id', ...requiredTestHeaders, 'individualscore', 'individualscores'];
                            
                            // Check for required headers
                            for (const reqHeader of requiredTestHeaders) {
                                const foundHeader = headers.find(h => h.includes(reqHeader));
                                if (!foundHeader) {
                                    throw new Error(`Header mancante: '${reqHeader}'.`);
                                }
                            }
                            
                            // Map headers to indices
                            const headerIndexMap = {}; 
                            headers.forEach((header, index) => {
                                if (header.includes('completiondate')) headerIndexMap['completionDate'] = index;
                                else if (header.includes('testname')) headerIndexMap['testName'] = index;
                                else if (header.includes('totalscore')) headerIndexMap['totalScore'] = index;
                                else if (header.includes('individualscore')) headerIndexMap['individualScores'] = index;
                            });
                            
                            let imp = 0, skip = 0, dup = 0; const importedTests = []; const errors = [];
                            
                            for (let i = 1; i < lines.length; i++) {
                                const line = lines[i]; if (!line.trim()) continue;
                                const values = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(v => {
                                    let value = v.trim();
                                    if (value.startsWith('"') && value.endsWith('"')) {
                                        value = value.substring(1, value.length - 1);
                                    }
                                    return value.replace(/""/g, '"');
                                });
                                
                                const testData = {};
                                Object.keys(headerIndexMap).forEach(key => {
                                    const index = headerIndexMap[key];
                                    testData[key] = values[index] !== undefined ? values[index] : '';
                                });
                                
                                if (!testData.completionDate || !/^\d{4}-\d{2}-\d{2}/.test(testData.completionDate)) {
                                    errors.push(`L${i + 1}: Data non valida.`);
                                    skip++;
                                    continue;
                                }
                                
                                // Parse individual scores
                                let individualScores = [];
                                if (testData.individualScores) {
                                    try {
                                        // Try to parse as JSON array or as semicolon-separated values
                                        if (testData.individualScores.startsWith('[')) {
                                            individualScores = JSON.parse(testData.individualScores);
                                        } else {
                                            individualScores = testData.individualScores.split(';').map(s => parseInt(s, 10) || null);
                                        }
                                    } catch (e) {
                                        errors.push(`L${i + 1}: Formato punteggi individuali non valido.`);
                                        skip++;
                                        continue;
                                    }
                                }
                                
                                const newTest = {
                                    id: `imported_test_${new Date().getTime()}_${i}`,
                                    testName: testData.testName,
                                    completionDate: testData.completionDate,
                                    totalScore: parseInt(testData.totalScore, 10) || 0,
                                    individualScores: individualScores
                                };
                                
                                importedTests.push(newTest);
                                imp++;
                            }
                            
                            // Check for duplicates and add tests
                            const existingTestDates = new Set(appState.testResults.map(t => t.completionDate + '_' + t.testName));
                            let addedTests = 0;
                            
                            importedTests.forEach(testResult => {
                                const testKey = testResult.completionDate + '_' + testResult.testName;
                                if (!existingTestDates.has(testKey)) {
                                    appState.testResults.push(testResult);
                                    existingTestDates.add(testKey);
                                    addedTests++;
                                } else {
                                    errors.push(`Test ${testResult.testName} del ${testResult.completionDate} duplicato.`);
                                    dup++;
                                }
                            });
                            
                            if (addedTests > 0) {
                                await saveTestResults();
                            }
                            
                            let finalMsg = `Importazione Test: ${addedTests} aggiunti.`;
                            if (skip > 0) finalMsg += ` ${skip} saltati (formato).`;
                            if (dup > 0) finalMsg += ` ${dup} saltati (duplicati).`;
                            if (errors.length > 0) {
                                finalMsg += `<br>Errori (max 5):<br><small>${errors.slice(0, 5).join('<br>')}</small>`;
                            }
                            
                            showUIMessage(DOM.data.importMessage, finalMsg, addedTests > 0 ? 'success' : 'error', 10000);
                        } else {
                            // Handle regular entries import (original code)
                            const requiredHeaders = ['date', 'mood', 'sleep', 'energy', 'anxiety', 'dissociation', 'boredom']; 
                            const allExpectedHeaders = ['id', ...requiredHeaders, 'steps', 'phoneminutes', 'kmrun', 'notes'];
                            
                            for (const reqHeader of requiredHeaders) {
                                if (!headers.includes(reqHeader)) {
                                    throw new Error(`Header mancante: '${reqHeader}'.`);
                                }
                            }
                            
                            const headerIndexMap = {}; 
                            headers.forEach((header, index) => {
                                if (allExpectedHeaders.includes(header)) {
                                    let key = header;
                                    if (key === 'phoneminutes') key = 'phoneMinutes';
                                    if (key === 'kmrun') key = 'kmRun';
                                    headerIndexMap[key] = index;
                                }
                            });
                            
                            let imp = 0, skip = 0, dup = 0; const importedEntries = []; const errors = [];
                            
                            for (let i = 1; i < lines.length; i++) {
                                const line = lines[i]; if (!line.trim()) continue;
                                const values = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(v => {
                                    let value = v.trim();
                                    if (value.startsWith('"') && value.endsWith('"')) {
                                        value = value.substring(1, value.length - 1);
                                    }
                                    return value.replace(/""/g, '"');
                                });
                                
                                const entryData = {};
                                Object.keys(headerIndexMap).forEach(key => {
                                    const index = headerIndexMap[key];
                                    entryData[key] = values[index] !== undefined ? values[index] : '';
                                });
                                
                                if (!entryData.date || !/^\d{4}-\d{2}-\d{2}$/.test(entryData.date)) {
                                    errors.push(`L${i + 1}: Data non valida.`);
                                    skip++;
                                    continue;
                                }
                                
                                const numericFields = ['mood', 'sleep', 'energy', 'anxiety', 'dissociation', 'boredom', 'steps', 'phoneMinutes', 'kmRun'];
                                let numErr = false;
                                
                                for (const f of numericFields) {
                                    const v = entryData[f];
                                    if (v && isNaN(parseFloat(String(v).replace(',', '.')))) {
                                        errors.push(`L${i + 1}: Valore non numerico per '${f}'.`);
                                        numErr = true;
                                        break;
                                    }
                                }
                                
                                if (numErr) {
                                    skip++;
                                    continue;
                                }
                                
                                const newEntry = {
                                    id: entryData.id || `imported_${new Date(entryData.date).getTime()}_${i}`,
                                    date: entryData.date,
                                    mood: Math.max(0, Math.min(10, parseInt(entryData.mood, 10) || 0)),
                                    sleep: Math.max(0, Math.min(10, parseInt(entryData.sleep, 10) || 0)),
                                    energy: Math.max(0, Math.min(10, parseInt(entryData.energy, 10) || 0)),
                                    anxiety: Math.max(0, Math.min(10, parseInt(entryData.anxiety, 10) || 0)),
                                    dissociation: Math.max(0, Math.min(10, parseInt(entryData.dissociation, 10) || 0)),
                                    boredom: Math.max(0, Math.min(10, parseInt(entryData.boredom, 10) || 0)),
                                    steps: Math.max(0, parseInt(entryData.steps, 10) || 0),
                                    phoneMinutes: Math.max(0, parseInt(entryData.phoneMinutes, 10) || 0),
                                    kmRun: Math.max(0, parseFloat(String(entryData.kmRun || '0').replace(',', '.')) || 0),
                                    notes: String(entryData.notes || '')
                                };
                                
                                importedEntries.push(newEntry);
                                imp++;
                            }
                            
                            const currentEntryDates = new Set(appState.entries.map(e => e.date));
                            let added = 0;
                            
                            importedEntries.forEach(impEntry => {
                                if (!currentEntryDates.has(impEntry.date)) {
                                    appState.entries.push(impEntry);
                                    currentEntryDates.add(impEntry.date);
                                    added++;
                                } else {
                                    errors.push(`Data ${impEntry.date} duplicata.`);
                                    dup++;
                                }
                            });
                            
                            if (added > 0) {
                                await saveEntries();
                            }
                            
                            let finalMsg = `Importazione Dati: ${added} aggiunte.`;
                            if (skip > 0) finalMsg += ` ${skip} saltate (formato).`;
                            if (dup > 0) finalMsg += ` ${dup} saltate (duplicati).`;
                            if (errors.length > 0) {
                                finalMsg += `<br>Errori (max 5):<br><small>${errors.slice(0, 5).join('<br>')}</small>`;
                            }
                            
                            showUIMessage(DOM.data.importMessage, finalMsg, added > 0 ? 'success' : 'error', 10000);
                        }
                    } catch (error) {
                        console.error("Import Error:", error);
                        showUIMessage(DOM.data.importMessage, `Errore: ${error.message}`, 'error', 10000);
                    } finally {
                        setButtonLoadingState(DOM.data.importBtnTrigger, false);
                        DOM.data.importFileInput.value = '';
                    }
                };
                reader.onerror = function() {
                    console.error("File Read Error:", reader.error);
                    showUIMessage(DOM.data.importMessage, 'Errore lettura file.', 'error');
                    setButtonLoadingState(DOM.data.importBtnTrigger, false);
                    DOM.data.importFileInput.value = '';
                };
                reader.readAsText(file);
            }

            // --- Test Logic ---
            function renderTestList() {
                DOM.takeTest.testListContainer.innerHTML = '';
                const fragment = document.createDocumentFragment();
                
                // Aggiungi conteggio dinamico dei test
                const testCount = Object.keys(TESTS_DATA).length;
                console.log(`Rendering ${testCount} tests:`, Object.keys(TESTS_DATA));
                
                const countDisplay = document.createElement('p');
                countDisplay.className = 'test-count-display';
                countDisplay.style.marginBottom = '1.5rem';
                countDisplay.style.color = 'var(--text-secondary)';
                countDisplay.style.fontWeight = '500';
                countDisplay.innerHTML = `<strong>${testCount} test disponibili</strong> da compilare:`;
                fragment.appendChild(countDisplay);
                
                Object.values(TESTS_DATA).forEach((test, index) => {
                    const card = document.createElement('div'); 
                    card.className = 'test-card';
                    card.style.animationDelay = `${index * 0.1}s`; // Animazione progressiva
                    card.innerHTML = `<h3>${test.name}</h3> <p>${test.numQuestions} domande. Scala 0-3.</p> <button class="btn btn-secondary start-test-btn" data-testid="${test.id}">Inizia Test</button>`;
                    fragment.appendChild(card);
                });
                DOM.takeTest.testListContainer.appendChild(fragment);
            }
            function startTest(testId) {
                const testData = TESTS_DATA[testId]; if (!testData) { console.error("Test not found:", testId); return; }
                appState.currentTest = { id: testId, name: testData.name, questions: testData.questions, scores: new Array(testData.numQuestions).fill(null), currentIndex: 0 };
                DOM.takeTest.resultsArea.style.display = 'none'; DOM.takeTest.modalScoreErrorMessage.style.display = 'none';
                displayCurrentQuestion(); showTestModal();
            }
            function showTestModal() { DOM.takeTest.modalOverlay.classList.add('visible'); DOM.takeTest.modalScoreOptions[0]?.focus(); }
            function hideTestModal() { DOM.takeTest.modalOverlay.classList.remove('visible'); }
            function displayCurrentQuestion() {
                const { name, questions, scores, currentIndex } = appState.currentTest; const totalQuestions = questions.length;
                DOM.takeTest.modalTitle.textContent = `${name}`; DOM.takeTest.modalQuestion.textContent = questions[currentIndex];
                DOM.takeTest.modalProgress.textContent = `Domanda ${currentIndex + 1} / ${totalQuestions}`;
                DOM.takeTest.modalPrevBtn.disabled = currentIndex === 0; DOM.takeTest.modalNextBtn.textContent = (currentIndex === totalQuestions - 1) ? 'Fine' : 'Avanti';
                DOM.takeTest.modalScoreOptions.forEach(radio => { radio.checked = (parseInt(radio.value, 10) === scores[currentIndex]); });
                DOM.takeTest.modalScoreErrorMessage.style.display = 'none';
            }
            function handleTestNavigation(direction) {
                 const { questions, scores, currentIndex } = appState.currentTest; const currentScore = getSelectedScore();
                 if (direction === 1 || (direction === 0 && currentIndex === questions.length - 1)) {
                     if (currentScore === null) { DOM.takeTest.modalScoreErrorMessage.style.display = 'block'; return; }
                     else { DOM.takeTest.modalScoreErrorMessage.style.display = 'none'; }
                 }
                 if (currentScore !== null) { scores[currentIndex] = currentScore; }
                if (direction === 1) {
                    if (currentIndex < questions.length - 1) { appState.currentTest.currentIndex++; displayCurrentQuestion(); }
                    else { finishTest(); }
                } else if (direction === -1) {
                    if (currentIndex > 0) { appState.currentTest.currentIndex--; displayCurrentQuestion(); }
                }
            }
            function getSelectedScore() { const c = DOM.takeTest.modalScoring.querySelector('input[name="score"]:checked'); return c ? parseInt(c.value, 10) : null; }
            async function finishTest() {
                 const { id, name, scores, isEditing, editingCompletionDate } = appState.currentTest; 
                 const lastScore = getSelectedScore();
                 if (lastScore === null) { DOM.takeTest.modalScoreErrorMessage.style.display = 'block'; return; }
                 scores[appState.currentTest.currentIndex] = lastScore;
                 
                 // Calcola il punteggio totale usando solo le domande valide per questo test
                 const testData = TESTS_DATA[id];
                 const numQuestions = testData ? testData.numQuestions : scores.length;
                 const validScores = scores.slice(0, numQuestions);
                 const totalScore = validScores.reduce((sum, score) => sum + (score !== null ? score : 0), 0);
                 
                 // Debug: mostra cosa sta succedendo
                 console.log(`Test ${id}: scores.length=${scores.length}, numQuestions=${numQuestions}, totalScore=${totalScore}`);
                 console.log('Scores array:', scores);
                 console.log('Valid scores:', validScores);
                
                // Se stiamo modificando un test esistente
                if (isEditing && editingCompletionDate) {
                    // Trova l'indice del test da aggiornare
                    const testIndex = appState.testResults.findIndex(t => t.completionDate === editingCompletionDate);
                    
                    if (testIndex !== -1) {
                        // Mantiene la data originale ma aggiorna i punteggi
                        appState.testResults[testIndex].totalScore = totalScore;
                        appState.testResults[testIndex].individualScores = [...validScores];
                        
                        await saveTestResults();
                        updateCharts(); // Aggiorna i grafici con i nuovi dati
                        showUIMessage(DOM.diary.actionMessage, 'Test aggiornato con successo.', 'success', 3000);
                    }
                } else {
                    // Questo è un nuovo test
                    // Usa la data selezionata dal campo test-date o la data corrente
                    let testDate;
                    if (DOM.takeTest.testDateInput && DOM.takeTest.testDateInput.value) {
                        // Crea una data alle 12:00 del giorno selezionato
                        testDate = new Date(DOM.takeTest.testDateInput.value + 'T12:00:00');
                        // Verifica che la data sia valida, altrimenti usa la data corrente
                        if (isNaN(testDate.getTime())) {
                            const today = new Date();
                            today.setHours(12, 0, 0, 0);
                            testDate = today;
                        }
                    } else {
                        const today = new Date();
                        today.setHours(12, 0, 0, 0);
                        testDate = today;
                    }

                    const resultData = {
                        testId: id,
                        testName: name,
                        completionDate: testDate.toISOString(),
                        totalScore: totalScore,
                        individualScores: [...validScores]
                    };
                    appState.testResults.push(resultData);
                    await saveTestResults();
                }

                DOM.takeTest.resultTitle.textContent = `Risultato ${name}`;
                DOM.takeTest.resultScore.innerHTML = `Punteggio Totale: <strong>${totalScore}</strong>`;
                DOM.takeTest.resultsArea.style.display = 'block'; DOM.takeTest.resultsArea.focus();
                hideTestModal(); DOM.takeTest.resultsArea.scrollIntoView({ behavior: 'smooth' });
            }
            function handleTestModalClose() { hideTestModal(); }

            // --- UI Navigation & View Management ---
             /**
              * Cambia la vista corrente dell'applicazione
              * @param {string} viewName - Nome della vista da mostrare (form, chart, diary, takeTest, data)
              */
             function showView(viewName) {
                // Mappa dei nomi delle viste agli ID degli elementi
                const viewIdMap = {
                    form: 'form-view',
                    chart: 'chart-view',
                    correlations: 'correlations-view',
                    diary: 'diary-view',
                    takeTest: 'take-test-view',
                    data: 'data-view'
                };
                
                // Trova l'elemento della vista target
                const targetViewId = viewIdMap[viewName];
                const targetViewElement = document.getElementById(targetViewId);

                // Verifica che l'elemento esista
                if (!targetViewElement) { 
                    console.error("View element not found for:", viewName, `(tried ID: ${targetViewId})`);
                    return;
                }

                // Aggiorna lo stato attivo
                appState.activeView = viewName;

                // Aggiorna i pulsanti di navigazione
                DOM.nav.buttons.forEach(btn => {
                    const isActive = btn.id.startsWith(viewName);
                    btn.classList.toggle('active', isActive);
                });

                // Nascondi tutte le viste
                DOM.views.containers.forEach(view => { 
                    view.style.display = 'none';
                });

                // Mostra e anima la vista target
                targetViewElement.style.display = 'block';
                
                // Trick per riapplicare l'animazione
                targetViewElement.classList.remove('fade-in');
                void targetViewElement.offsetWidth; // Forza reflow
                targetViewElement.classList.add('fade-in');

                switch (viewName) {
                    case 'form':
                        if (!DOM.form.editingEntryId.value) { resetForm(); } else { DOM.form.dateInput.focus(); }
                        break;
                    case 'diary':
                        renderDiary(); DOM.diary.actionMessage.style.display = 'none';
                        break;
                    case 'chart':
                        updateCharts(); switchChartView(appState.activeChartView);
                        document.getElementById(`${appState.activeChartView}-chart-tab-btn`)?.focus();
                        break;
                    case 'correlations':
                        updateCorrelationChart();
                        document.getElementById('correlation-type')?.focus();
                        break;
                    case 'takeTest':
                        renderTestList(); DOM.takeTest.resultsArea.style.display = 'none';
                        break;
                    case 'data':
                        DOM.data.importMessage.style.display = 'none';
                        break;
                }
                 window.scrollTo(0, 0);
            }

            // --- Event Listeners ---
             /**
              * Configura tutti gli event listeners dell'applicazione
              * Organizzati per sezione per migliorare la leggibilità e manutenibilità
              */
             function setupEventListeners() {
                // ===== Navigazione principale =====
                
                // Bottone pagina intro
                // Gestore per bottone di start app
                const startBtn = document.getElementById('start-app');
                if (startBtn) {
                    startBtn.addEventListener('click', function() {
                        console.log("Utente ha cliccato la freccia per iniziare");
                        
                        // Nascondi la pagina intro e mostra immediatamente la pagina app 
                        // per evitare qualsiasi lag durante la transizione
                        document.getElementById('intro-page').style.display = 'none';
                        document.getElementById('app-page').style.display = 'flex';
                        
                        // Attiva immediatamente la visualizzazione del form
                        showView('form');
                        
                        // Messaggio di benvenuto per nuovi utenti
                        if (appState.entries.length === 0 && appState.testResults.length === 0) {
                            // Mostra il messaggio di benvenuto con un piccolo ritardo per assicurarsi 
                            // che la UI sia completamente caricata prima di mostrare il messaggio
                            setTimeout(() => {
                                showUIMessage(DOM.form.formMessage, "Benvenuto!", "success", 5000);
                            }, 100);
                        }
                    });
                }

                // Bottoni della barra di navigazione principale
                DOM.nav.formBtn.addEventListener('click', () => showView('form'));
                DOM.nav.chartBtn.addEventListener('click', () => showView('chart'));
                DOM.nav.correlationsBtn.addEventListener('click', () => showView('correlations'));
                DOM.nav.diaryBtn.addEventListener('click', () => showView('diary'));
                DOM.nav.takeTestBtn.addEventListener('click', () => showView('takeTest'));
                DOM.nav.dataBtn.addEventListener('click', () => showView('data'));

                // Form view listeners
                DOM.form.formElement.addEventListener('submit', handleSaveEntry);
                DOM.form.clearFormBtn.addEventListener('click', () => resetForm());
                SLIDER_MAP.forEach(({ input, valueEl, emoji }) => { input.addEventListener('input', () => updateSliderVisuals(input, valueEl, emoji)); });

                // Diary view listeners (delegation)
                DOM.views.diary.addEventListener('click', (event) => {
                    console.log("Click nel diario:", event.target);
                    
                    const editButton = event.target.closest('.edit-entry-btn');
                    const deleteButton = event.target.closest('.delete-entry-btn');
                    const deleteTestButton = event.target.closest('.delete-test-btn');
                    const editTestButton = event.target.closest('.edit-test-btn');
                    
                    console.log("Trovati elementi:", {
                        editButton: !!editButton,
                        deleteButton: !!deleteButton,
                        deleteTestButton: !!deleteTestButton,
                        editTestButton: !!editTestButton
                    });
                    
                    if (editButton) { 
                        console.log("Cliccato edit entry button");
                        populateFormForEdit(editButton.dataset.id); 
                    }
                    else if (deleteButton) { 
                        console.log("Cliccato delete entry button");
                        handleDeleteEntry(deleteButton.dataset.id); 
                    }
                    else if (deleteTestButton) { 
                        console.log("Cliccato delete test button con ID:", deleteTestButton.dataset.id);
                        handleDeleteTest(deleteTestButton.dataset.id); 
                    }
                    else if (editTestButton) { 
                        console.log("Cliccato edit test button");
                        editTest(editTestButton.dataset.id, editTestButton.dataset.testId); 
                    }
                });
                
                // Diary filter buttons
                DOM.diary.filterButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const filterType = e.target.id.replace('filter-', '');
                        appState.diaryFilter = filterType;
                        DOM.diary.filterButtons.forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        renderDiary();
                    });
                });

                // Chart view listeners
                DOM.chart.chartTabsContainer.addEventListener('click', handleChartTabClick);
                DOM.chart.chartTabsContainer.addEventListener('keydown', handleChartTabKeydown);
                DOM.chart.prevWeekBtn.addEventListener('click', () => changeWeek(-1));
                DOM.chart.nextWeekBtn.addEventListener('click', () => changeWeek(1));
                DOM.chart.viewAllDataBtn.addEventListener('click', (e) => {
                    // Se siamo nella vista tabella domande o il pulsante è disabilitato, non fare nulla
                    if (appState.activeChartView === 'tests' && appState.activeTestView === 'table' || e.target.classList.contains('disabled')) {
                        return;
                    }
                    setChartViewMode('all');
                });
                
                DOM.chart.viewCurrentWeekDataBtn.addEventListener('click', (e) => {
                    // Se siamo nella vista tabella domande o il pulsante è disabilitato, non fare nulla
                    if (appState.activeChartView === 'tests' && appState.activeTestView === 'table' || e.target.classList.contains('disabled')) {
                        return;
                    }
                    setChartViewMode('weekly');
                });
                
                // MindTrack subtabs
                DOM.chart.mindtrackSubtabs.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const chartType = e.target.dataset.chart;
                        appState.activeMindtrackChart = chartType;
                        DOM.chart.mindtrackSubtabs.forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        updateMindtrackChart();
                    });
                });
                
                // Tests subtabs
                DOM.chart.testsSubtabs.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const viewType = e.target.dataset.view;
                        appState.activeTestView = viewType;
                        DOM.chart.testsSubtabs.forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        
                        // Gestione casi speciali per le diverse viste
                        // L'altezza del contenitore verrà impostata in base al tipo di test
                        
                        // Nascondi/mostra gli elementi appropriati
                        const testsChart = document.getElementById('tests-chart');
                        const testDetailsContainer = document.getElementById('test-details-container');
                        const testSelector = document.getElementById('test-selector');
                        
                        // Quando si passa a "Punteggi Totali", imposta selectedTest su "all"
                        if (viewType === 'totals') {
                            appState.selectedTest = 'all';
                        }
                        
                        // Mostra il selettore dei test solo nella vista "Tabella domande"
                        testSelector.style.display = viewType === 'table' ? 'block' : 'none';
                        
                        // Gestione dei pulsanti "Tutto" e "Sett. corrente" solo per la vista tabella domande
                        const viewAllDataBtn = document.getElementById('view-all-data');
                        const viewCurrentWeekDataBtn = document.getElementById('view-current-week-data');
                        
                        if (viewType === 'table') {
                            // In modalità tabella domande, disabilita i pulsanti
                            viewAllDataBtn.classList.add('disabled');
                            viewCurrentWeekDataBtn.classList.add('disabled');
                        } else {
                            // In modalità punteggi totali, rimuovi la classe disabled
                            viewAllDataBtn.classList.remove('disabled');
                            viewCurrentWeekDataBtn.classList.remove('disabled');
                        }
                        
                        // Nascondi tutti i container
                        testsChart.style.display = 'none';
                        testDetailsContainer.style.display = 'none';
                        
                        // Mostra il container appropriato in base alla vista selezionata
                        if (viewType === 'totals') {
                            // Reimpostare gli stili per la vista grafico
                            const chartView = document.getElementById('chart-view');
                            if (chartView.style.paddingBottom) {
                                chartView.style.paddingBottom = '';
                            }
                            
                            // Mostra "Tutti i test" nel selettore per la vista totali
                            const allOption = DOM.chart.testTypeSelect.querySelector('option[value="all"]');
                            if (allOption) {
                                allOption.style.display = '';
                            }
                            
                            // Mostra il grafico
                            testsChart.style.display = 'block';
                            updateTestsChart();
                        } else if (viewType === 'table') {
                            // Nascondi "Tutti i test" nel selettore per la vista tabella
                            const allOption = DOM.chart.testTypeSelect.querySelector('option[value="all"]');
                            if (allOption) {
                                allOption.style.display = 'none';
                                
                                // Se era selezionato "Tutti i test", passa al primo test disponibile
                                if (appState.selectedTest === 'all') {
                                    DOM.chart.testTypeSelect.value = 'phq9';
                                    appState.selectedTest = 'phq9';
                                }
                            }
                            
                            // Mostra il contenitore delle tabelle
                            testDetailsContainer.style.display = 'block';
                            
                            // Genera la tabella
                            generateTestDetailsTable();
                        }
                    });
                });
                
                // Test type selector
                DOM.chart.testTypeSelect.addEventListener('change', (e) => {
                    appState.selectedTest = e.target.value;
                    
                    // Reset dell'altezza quando cambiamo test, non necessario
                    // La generateTestDetailsTable imposterà l'altezza corretta in base al test
                    
                    if (appState.activeTestView === 'table') {
                        generateTestDetailsTable();
                    } else {
                        updateTestsChart();
                    }
                });
                
                
                // Funzione per generare la tabella di dettaglio dei test
                function generateTestDetailsTable() {
                    const container = document.getElementById('test-details-container');
                    if (!container) return;
                    
                    let filteredResults = appState.testResults;
                    
                    // Filtra per test selezionato
                    if (appState.selectedTest !== 'all') {
                        filteredResults = filteredResults.filter(r => r.testId === appState.selectedTest);
                    }
                    
                    // Filtra per settimana selezionata
                    if (appState.chartViewMode === 'weekly' && appState.weeksData.length > 0) {
                        const currentWeek = appState.weeksData[appState.currentWeekOffset];
                        if (currentWeek) {
                            const startDate = new Date(currentWeek.startDate);
                            const endDate = new Date(currentWeek.endDate);
                            endDate.setHours(23, 59, 59, 999); // Fine della giornata
                            
                            filteredResults = filteredResults.filter(r => {
                                const resultDate = new Date(r.completionDate);
                                return resultDate >= startDate && resultDate <= endDate;
                            });
                        }
                    }
                    
                    // Ordina per data (dal più vecchio al più recente)
                    filteredResults.sort((a, b) => new Date(a.completionDate) - new Date(b.completionDate));
                    
                    // Se non ci sono risultati filtrati...
                    if (filteredResults.length === 0) {
                        // Controlla se è già presente un messaggio di errore nel grafico
                        const chartEmptyMessage = document.getElementById('chart-empty-message');
                        
                        // In ogni caso, non mostrare un messaggio nella tabella ma usa quello centralizzato
                        container.innerHTML = '';
                        
                        // Mostra sempre il messaggio centralizzato
                        chartEmptyMessage.style.display = 'block';
                        chartEmptyMessage.innerHTML = '<strong>Nessun risultato disponibile.</strong><br>Completa un test per visualizzare i dati in tabella.';
                        return;
                    }
                    
                    // L'opzione "Tutti i test" non dovrebbe essere disponibile nella vista tabella
                    if (appState.selectedTest === 'all') {
                        // Se per qualche motivo siamo arrivati qui con "Tutti i test" selezionato,
                        // imposta automaticamente il primo test disponibile
                        appState.selectedTest = 'phq9';
                        DOM.chart.testTypeSelect.value = 'phq9';
                        
                        // Filtra nuovamente i risultati con il nuovo test selezionato
                        filteredResults = appState.testResults.filter(r => r.testId === appState.selectedTest);
                        
                        // Ordina per data (dal più vecchio al più recente)
                        filteredResults.sort((a, b) => new Date(a.completionDate) - new Date(b.completionDate));
                    }
                    
                    // Per un test specifico, mostra tutti i dati con l'andamento
                    const testData = TESTS_DATA[appState.selectedTest];
                    if (!testData) {
                        container.innerHTML = '<p class="empty-message"><strong>Test non trovato.</strong></p>';
                        return;
                    }
                    
                    // Preparare la tabella per un test specifico
                    let html = `<h3>Dettagli test ${testData.name}</h3>`;
                    html += '<div style="overflow-x: auto; width: 100%;">'; // Container con scorrimento orizzontale
                    html += '<table class="test-details-table">';
                    html += '<thead><tr>';
                    html += '<th>Domanda</th>';
                    
                    filteredResults.forEach(result => {
                        const dateFormatted = formatDateTimeForDisplay(result.completionDate);
                        html += `<th>${dateFormatted}</th>`;
                    });
                    
                    html += '<th>Andamento</th>';
                    html += '</tr></thead><tbody>';
                    
                    // Per ogni domanda, aggiungi una riga
                    for (let i = 0; i < testData.questions.length; i++) {
                        const questionTitle = testData.questions[i].split(': ')[1] || `Domanda ${i + 1}`;
                        
                        html += '<tr>';
                        html += `<td>${questionTitle}</td>`;
                        
                        // Valori per ogni compilazione
                        let values = [];
                        filteredResults.forEach(result => {
                            let value = '-';
                            // Verifica che individualScores esista e abbia un valore all'indice i
                            if (result.individualScores && result.individualScores.length > i) {
                                value = result.individualScores[i];
                                values.push(Number(value)); // Converti a numero per il calcolo dell'andamento
                            } else {
                                values.push(value); // Mantieni il valore '-' nell'array
                            }
                            html += `<td>${value}</td>`;
                        });
                        
                        // Calcola l'andamento (solo se ci sono almeno 2 valori)
                        if (values.length >= 2 && values[values.length-1] !== '-' && values[values.length-2] !== '-') {
                            const latest = values[values.length-1]; // L'ultimo valore (più recente)
                            const previous = values[values.length-2]; // Il penultimo valore
                            const diff = latest - previous;
                            
                            let trendIndicator, trendClass, trendText;
                            if (diff > 0) {
                                trendIndicator = '↑';
                                trendClass = 'trend-up';
                                trendText = `+${diff} (Peggioramento)`;
                            } else if (diff < 0) {
                                trendIndicator = '↓';
                                trendClass = 'trend-down';
                                trendText = `${diff} (Miglioramento)`;
                            } else {
                                trendIndicator = '→';
                                trendClass = 'trend-stable';
                                trendText = 'Stabile';
                            }
                            
                            html += `<td class="trend-cell"><span class="trend-indicator ${trendClass}">${trendIndicator}</span> ${trendText}</td>`;
                        } else {
                            html += '<td>-</td>';
                        }
                        
                        html += '</tr>';
                    }
                    
                    // Aggiungi riga per il punteggio totale
                    html += '<tr style="font-weight: 600;">';
                    html += '<td>Punteggio Totale</td>';
                    
                    let totalValues = [];
                    filteredResults.forEach(result => {
                        totalValues.push(result.totalScore);
                        html += `<td>${result.totalScore}</td>`;
                    });
                    
                    // Calcola l'andamento del punteggio totale
                    if (totalValues.length >= 2) {
                        const latest = totalValues[totalValues.length-1]; // L'ultimo valore (più recente)
                        const previous = totalValues[totalValues.length-2]; // Il penultimo valore
                        const diff = latest - previous;
                        
                        let trendIndicator, trendClass, trendText;
                        if (diff > 0) {
                            trendIndicator = '↑';
                            trendClass = 'trend-up';
                            trendText = `+${diff} (Peggioramento)`;
                        } else if (diff < 0) {
                            trendIndicator = '↓';
                            trendClass = 'trend-down';
                            trendText = `${diff} (Miglioramento)`;
                        } else {
                            trendIndicator = '→';
                            trendClass = 'trend-stable';
                            trendText = 'Stabile';
                        }
                        
                        html += `<td class="trend-cell"><span class="trend-indicator ${trendClass}">${trendIndicator}</span> ${trendText}</td>`;
                    } else {
                        html += '<td>-</td>';
                    }
                    
                    html += '</tr>';
                    html += '</tbody></table>';
                    html += '</div>'; // Chiude il container scrollabile
                    
                    // Nessuna nota informativa
                    
                    container.innerHTML = html;
                    
                    // Adatta dinamicamente l'altezza del contenitore al contenuto della tabella
                    // Imposta l'altezza del contenitore in base al tipo di test
                    const chartView = document.getElementById('chart-view');
                    if (chartView) {
                        // Seleziona l'altezza adeguata in base al tipo di test
                        let containerHeight = 0;
                        
                        // Se ci sono dati, usa l'altezza basata sul numero di domande del test
                        if (filteredResults.length > 0) {
                            // Calcoliamo l'altezza in base alle domande con spazio finale uniforme
                            // Usiamo valori più alti per assicurarci che tutto il contenuto entri
                            
                            // Valori ridotti di 100px in totale 
                            const questionHeight = 40; // pixel per domanda
                            const baseSpace = 40;      // spazio fisso alla fine
                            
                            // Determina l'altezza base in base al tipo di test
                            let baseHeight = 0;
                            switch (appState.selectedTest) {
                                case 'phq9':    // 9 domande
                                    baseHeight = 330;    // 530 - 200 = 330
                                    break;
                                case 'bdiii':   // 21 domande
                                    baseHeight = 930;    // 1130 - 200 = 930
                                    break;
                                case 'cesd':    // 20 domande
                                    baseHeight = 880;    // 1080 - 200 = 880
                                    break;
                                case 'hads':    // 14 domande
                                    baseHeight = 580;    // 780 - 200 = 580
                                    break;
                                case 'idssr30': // 30 domande
                                    baseHeight = 1380;   // 1580 - 200 = 1380
                                    break;
                                default:
                                    baseHeight = 380;    // 580 - 200 = 380
                                    break;
                            }
                            
                            // Imposta l'altezza base
                            containerHeight = baseHeight;
                            
                            // Se ci sono più di 4 test, aggiungi 175px extra all'altezza
                            // Questo fornisce spazio sufficiente per lo scorrimento orizzontale
                            if (filteredResults.length > 4) {
                                containerHeight += 175;
                            }
                        } else {
                            // Se non ci sono dati, contenitore piccolo
                            containerHeight = 100;
                        }
                        
                        // Imposta l'altezza fissa senza delay
                        chartView.style.paddingBottom = containerHeight + 'px';
                    }
                }

                // Data view listeners
                DOM.data.exportBtn.addEventListener('click', handleExportData);
                DOM.data.importBtnTrigger.addEventListener('click', () => DOM.data.importFileInput.click());
                DOM.data.importFileInput.addEventListener('change', handleImportData);

                // Take Test view listeners (delegation)
                DOM.takeTest.testListContainer.addEventListener('click', (event) => {
                    const startButton = event.target.closest('.start-test-btn');
                    if (startButton && startButton.dataset.testid) { startTest(startButton.dataset.testid); }
                });

                // Test Modal Listeners
                DOM.takeTest.modalCloseBtn.addEventListener('click', handleTestModalClose);
                DOM.takeTest.modalPrevBtn.addEventListener('click', () => handleTestNavigation(-1));
                DOM.takeTest.modalNextBtn.addEventListener('click', () => handleTestNavigation(1));
                DOM.takeTest.modalScoring.addEventListener('change', () => { if (getSelectedScore() !== null) { DOM.takeTest.modalScoreErrorMessage.style.display = 'none'; } });
                DOM.takeTest.modalOverlay.addEventListener('click', (event) => { if (event.target === DOM.takeTest.modalOverlay) { handleTestModalClose(); } });
                document.addEventListener('keydown', (event) => { if (event.key === 'Escape' && DOM.takeTest.modalOverlay.classList.contains('visible')) { handleTestModalClose(); } });
            }

            // App Configuration
            
            /**
             * Gestisce l'autenticazione e la navigazione dell'app
             */
            function handleAuth() {
                const userBtn = document.getElementById('user-btn');
                const loginBtn = document.getElementById('login-btn');
                const userEmail = document.getElementById('user-email');
                const loginPage = document.getElementById('login-page');
                const introPage = document.getElementById('intro-page');
                const appPage = document.getElementById('app-page');
                
                // Controlla se l'utente ha già scelto di saltare il login
                const skipLogin = localStorage.getItem('skipLogin') === 'true';
                
                if (skipLogin) {
                    // Utente già autenticato localmente
                    console.log("User is signed in locally");
                    
                    // Nasconde la pagina di login e mostra l'app
                    document.getElementById('login-page').style.display = 'none';
                    document.getElementById('intro-page').style.display = 'flex';
                } else {
                    // Utente non autenticato
                    console.log("User is not authenticated");
                }
            }
            
            /**
             * Gestisce il login dell'utente con memorizzazione locale
             * @param {string} nickname - Nickname dell'utente
             * @param {string} password - Password dell'utente
             */
            function handleLogin(nickname, password) {
                try {
                    // Semplice verifica base
                    if (nickname && password) {
                        // Memorizza l'autenticazione locale
                        localStorage.setItem('skipLogin', 'true');
                        localStorage.setItem('nickname', nickname);
                        
                        // Transizione alla pagina principale usando display
                        document.getElementById('login-page').style.display = 'none';
                        document.getElementById('intro-page').style.display = 'flex';
                        
                        showUIMessage(document.getElementById('login-form-message'), "Accesso effettuato con successo.", "success", 3000);
                    } else {
                        showUIMessage(document.getElementById('login-error'), "Inserisci nickname e password.", "error", 5000);
                    }
                } catch (error) {
                    console.error("Login error:", error);
                    showUIMessage(document.getElementById('login-error'), "Errore durante l'accesso.", "error", 5000);
                }
            }
            
            function handleLogout() {
                // Rimuovi l'autenticazione locale
                localStorage.removeItem('skipLogin');
                localStorage.removeItem('nickname');
                
                // Reindirizza all'inizio
                document.getElementById('login-page').style.display = 'flex';
                document.getElementById('intro-page').style.display = 'none';
                document.getElementById('app-page').style.display = 'none';
                
                console.log("Logout completed");
            }
            
            // Funzione per garantire che i dati siano salvati remoto e localmente
            async function saveDataLocally() {
                try {
                    // Salva al server remoto
                    await salvaDatoRemoto(appState.entries);
                    
                    // Salva anche in localStorage le entries come backup
                    localStorage.setItem(ENTRY_STORAGE_KEY, JSON.stringify(appState.entries));
                    
                    // Aggiorna UI
                    populateWeeksData();
                    updateCharts();
                    renderDiary();
                } catch (error) {
                    console.error("Error saving data remotely:", error);
                    // Salva comunque in localStorage come fallback
                    localStorage.setItem(ENTRY_STORAGE_KEY, JSON.stringify(appState.entries));
                }
            }
            
            // Funzione per salvare i risultati dei test remotamente e localmente
            async function saveTestResultsLocally() {
                try {
                    // Usa l'endpoint specifico per i test invece di /salva generico
                    const response = await fetch(`${API_BASE}/tests`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contenuto: JSON.stringify(appState.testResults)
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Errore server: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    if (!result.ok) {
                        throw new Error(result.errore || 'Errore nel salvataggio remoto');
                    }
                    
                    console.log("Test salvati con successo al server");
                    
                    // Salva anche in localStorage come backup
                    localStorage.setItem(TEST_RESULTS_STORAGE_KEY, JSON.stringify(appState.testResults));
                } catch (error) {
                    console.error("Error saving test results remotely:", error);
                    // Salva comunque in localStorage come fallback
                    localStorage.setItem(TEST_RESULTS_STORAGE_KEY, JSON.stringify(appState.testResults));
                    
                    // Mostra errore all'utente
                    showUIMessage(DOM.diary.actionMessage, 'Errore nel salvataggio remoto dei test. Salvati localmente.', 'error', 5000);
                }
            }
            
            async function salvaDatoRemoto(contenuto) {
                const res = await fetch(`${API_BASE}/salva`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ contenuto: JSON.stringify(contenuto) })
                });
                const json = await res.json();
                if (!json.ok) console.error('Errore salvataggio:', json.errore);
            }

            async function caricaDatiRemoto() {
                const res = await fetch(`${API_BASE}/dati`);
                const dati = await res.json();
                return dati.map(item => item.contenuto);
            }
            
            /**
             * Configura tutti gli event listeners relativi all'autenticazione
             */
            function setupLoginListeners() {
                // All'inizio, vogliamo sempre mostrare il login page
                console.log("Inizializzazione pagina login");
                
                // Assicuriamoci che la pagina di login sia visibile inizialmente
                // e le altre pagine siano nascoste
                document.getElementById('login-page').style.display = 'flex';
                document.getElementById('intro-page').style.display = 'none';
                document.getElementById('app-page').style.display = 'none';
                
                // Bottone per saltare il login
                const skipLoginBtn = document.getElementById('skip-login-btn');
                if (skipLoginBtn) {
                    skipLoginBtn.addEventListener('click', function() {
                        console.log("Utente ha cliccato 'Salta accesso'");
                        localStorage.setItem('skipLogin', 'true');
                        
                        // Nascondi la pagina di login
                        document.getElementById('login-page').style.display = 'none';
                        
                        // Mostra la pagina intro
                        document.getElementById('intro-page').style.display = 'flex';
                    });
                } else {
                    console.error("Bottone 'Salta accesso' non trovato!");
                }
                
                // Bottone login nella barra di navigazione
                const loginBtn = document.getElementById('login-btn');
                if (loginBtn) {
                    loginBtn.addEventListener('click', function() {
                        // Torna alla pagina di login
                        document.getElementById('intro-page').style.display = 'none';
                        document.getElementById('app-page').style.display = 'none';
                        document.getElementById('login-page').style.display = 'flex';
                    });
                }
                
                // Bottone user nella nav (per logout)
                const userBtn = document.getElementById('user-btn');
                if (userBtn) {
                    userBtn.addEventListener('click', () => {
                        if (confirm('Vuoi uscire dall\'account?')) {
                            handleLogout();
                            // Se l'utente fa logout, mostra il login page la prossima volta
                            localStorage.removeItem('skipLogin');
                            // Torna alla pagina di login
                            document.getElementById('intro-page').style.display = 'none';
                            document.getElementById('app-page').style.display = 'none';
                            document.getElementById('login-page').style.display = 'flex';
                        }
                    });
                }
                
                // Form login nella pagina iniziale
                document.getElementById('login-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    const nickname = document.getElementById('email').value;
                    const password = document.getElementById('password').value;
                    handleLogin(nickname, password);
                });
            }

            // --- Initialization ---
             /**
              * Inizializza l'applicazione MindTrack
              * Configura tutti i componenti necessari e carica i dati iniziali
              */
             async function initializeApp() {
                console.log("Initializing MindTrack App...");
                
                // 1. Inizializzazione applicazione locale
                
                // 2. Caricamento dati
                try {
                    await loadEntries();
                    await loadTestResults();
                } catch (error) {
                    console.error("Error loading data:", error);
                }
                
                // 3. Configurazione UI
                resetForm(false);
                setupEventListeners();
                
                // 4. Configurazione login - Deve essere eseguito per ultimo
                // in modo che non venga sovrascritto da altre configurazioni
                setupLoginListeners();
                
                // 4. Inizializzazione date e valori
                // Imposta la data corrente per il selettore data nella pagina dei test
                if (DOM.takeTest.testDateInput) {
                    const today = new Date();
                    today.setHours(12, 0, 0, 0); // Impostiamo a mezzogiorno per evitare problemi di timezone
                    DOM.takeTest.testDateInput.value = formatDateISO(today);
                }
                
                // 5. Configurazione viste
                // Scegli la modalità grafico in base alla presenza di dati
                // Se ci sono dati, mostra la vista settimanale con la settimana corrente
                if (appState.entries.length > 0) {
                    setChartViewMode('weekly');
                    // Trova e imposta la settimana corrente
                    const today = new Date();
                    let currentWeekIndex = appState.weeksData.findIndex(week => {
                        const startDate = new Date(week.startDate);
                        const endDate = new Date(week.endDate);
                        endDate.setHours(23, 59, 59, 999);
                        return today >= startDate && today <= endDate;
                    });
                    
                    if (currentWeekIndex === -1 && appState.weeksData.length > 0) {
                        currentWeekIndex = appState.weeksData.length - 1;
                    }
                    
                    appState.currentWeekOffset = Math.max(0, currentWeekIndex);
                } else {
                    setChartViewMode('all');
                }
                renderTestList();
                
                // 6. Attivazione tab iniziali
                // Attiva i primi subtab come default
                if (DOM.chart.mindtrackSubtabs.length > 0) {
                    DOM.chart.mindtrackSubtabs[0].classList.add('active');
                }
                if (DOM.chart.testsSubtabs.length > 0) {
                    DOM.chart.testsSubtabs[0].classList.add('active');
                }
                
                console.log("MindTrack App Initialized.");
            }
            
            // --- Correlation Functions ---
            function updateCorrelationChart() {
                const correlationType = document.getElementById('correlation-type').value;
                const customCorrelationDiv = document.getElementById('custom-correlation');
                
                // Mostra/nascondi i selettori personalizzati
                if (correlationType === 'custom') {
                    customCorrelationDiv.style.display = 'block';
                } else {
                    customCorrelationDiv.style.display = 'none';
                }
                
                // Determina gli assi X e Y
                let xAxis, yAxis;
                if (correlationType === 'custom') {
                    xAxis = document.getElementById('x-axis').value;
                    yAxis = document.getElementById('y-axis').value;
                } else {
                    const axes = correlationType.split('-');
                    xAxis = axes[0];
                    yAxis = axes[1];
                }
                
                // Prendi i dati dal appState
                const xData = [];
                const yData = [];
                
                appState.entries.forEach(entry => {
                    if (entry[xAxis] !== undefined && entry[yAxis] !== undefined) {
                        xData.push(entry[xAxis]);
                        yData.push(entry[yAxis]);
                    }
                });
                
                // Calcola il coefficiente di correlazione
                const correlation = calculateCorrelation(xData, yData);
                
                // Aggiorna le statistiche
                document.getElementById('correlation-coefficient').textContent = `Coefficiente di correlazione: ${correlation.toFixed(3)}`;
                document.getElementById('correlation-interpretation').textContent = interpretCorrelation(correlation);
                document.getElementById('data-points-count').textContent = `Numero di punti dati: ${xData.length}`;
                
                // Crea il grafico
                createCorrelationChart(xData, yData, xAxis, yAxis);
            }
            
            function calculateCorrelation(x, y) {
                if (x.length !== y.length || x.length === 0) return 0;
                
                const n = x.length;
                const sumX = x.reduce((a, b) => a + b, 0);
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = x.reduce((total, xi, i) => total + xi * y[i], 0);
                const sumX2 = x.reduce((total, xi) => total + xi * xi, 0);
                const sumY2 = y.reduce((total, yi) => total + yi * yi, 0);
                
                const numerator = n * sumXY - sumX * sumY;
                const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
                
                if (denominator === 0) return 0;
                return numerator / denominator;
            }
            
            function interpretCorrelation(r) {
                const absR = Math.abs(r);
                if (absR >= 0.9) return r > 0 ? "Correlazione positiva molto forte" : "Correlazione negativa molto forte";
                if (absR >= 0.7) return r > 0 ? "Correlazione positiva forte" : "Correlazione negativa forte";
                if (absR >= 0.5) return r > 0 ? "Correlazione positiva moderata" : "Correlazione negativa moderata";
                if (absR >= 0.3) return r > 0 ? "Correlazione positiva debole" : "Correlazione negativa debole";
                return "Correlazione molto debole o inesistente";
            }
            
            function createCorrelationChart(xData, yData, xLabel, yLabel) {
                const canvas = document.getElementById('correlation-chart');
                const ctx = canvas.getContext('2d');
                
                // Distruggi il grafico esistente se presente
                if (window.correlationChart) {
                    window.correlationChart.destroy();
                }
                
                // Crea i punti per il grafico scatter
                const dataPoints = xData.map((x, i) => ({ x: x, y: yData[i] }));
                
                // Calcola la linea di regressione
                const { slope, intercept } = calculateRegression(xData, yData);
                const minX = Math.min(...xData);
                const maxX = Math.max(...xData);
                const regressionLine = [
                    { x: minX, y: slope * minX + intercept },
                    { x: maxX, y: slope * maxX + intercept }
                ];
                
                // Mappa etichette più leggibili
                const labelMap = {
                    mood: 'Umore',
                    sleep: 'Sonno',
                    energy: 'Energia',
                    anxiety: 'Ansia',
                    dissociation: 'Dissociazione',
                    boredom: 'Noia',
                    steps: 'Passi',
                    phoneMinutes: 'Minuti telefono',
                    kmRun: 'Km corsi'
                };
                
                window.correlationChart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'Dati',
                            data: dataPoints,
                            backgroundColor: 'rgba(59, 130, 246, 0.5)',
                            borderColor: 'rgba(59, 130, 246, 1)',
                            pointRadius: 5,
                            pointHoverRadius: 7
                        }, {
                            label: 'Linea di regressione',
                            data: regressionLine,
                            type: 'line',
                            borderColor: 'rgba(239, 68, 68, 1)',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 0,
                            showLine: true,
                            fill: false
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `${labelMap[xLabel] || xLabel} vs ${labelMap[yLabel] || yLabel}`,
                                font: { size: 16 }
                            },
                            legend: {
                                display: true,
                                position: 'top'
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: labelMap[xLabel] || xLabel
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: labelMap[yLabel] || yLabel
                                }
                            }
                        }
                    }
                });
            }
            
            function calculateRegression(x, y) {
                const n = x.length;
                const sumX = x.reduce((a, b) => a + b, 0);
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = x.reduce((total, xi, i) => total + xi * y[i], 0);
                const sumX2 = x.reduce((total, xi) => total + xi * xi, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;
                
                return { slope, intercept };
            }
            
            // Gestione del cambio tipo di correlazione
            document.getElementById('correlation-type')?.addEventListener('change', updateCorrelationChart);
            document.getElementById('x-axis')?.addEventListener('change', updateCorrelationChart);
            document.getElementById('y-axis')?.addEventListener('change', updateCorrelationChart);
            
            // Rendi la funzione globale
            window.updateCorrelationChart = updateCorrelationChart;

            // Start the application
            initializeApp();
            

        }); // End DOMContentLoaded
    </script>
</body>
</html>